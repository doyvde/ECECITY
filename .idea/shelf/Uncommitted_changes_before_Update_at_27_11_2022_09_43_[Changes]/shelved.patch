Index: mabiblio.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\r\n// Created by denis on 02/11/2022.\r\n//\r\n\r\n#include \"mabiblio.h\"\r\n\r\n/////////////////bfs.c////////////////////////\r\nint* recherchepluscourtchemin(t_bfs* bfs,t_case*** kase)\r\n{\r\n    t_file* file;\r\n    t_case* temp;\r\n    int marque[NB_CASES_LIG][NB_CASES_COL];\r\n    int ligne,colonne,compteur;\r\n    int* longueurs;\r\n\r\n    longueurs=malloc(bfs->ordre*sizeof(int));\r\n    for(compteur=0;compteur<bfs->ordre;compteur++)\r\n    {\r\n        longueurs[compteur]=0;\r\n    }\r\n\r\n    file=file_creer();\r\n    for(ligne=0;ligne<NB_CASES_LIG;ligne++)\r\n    {\r\n        for(colonne=0;colonne<NB_CASES_COL;colonne++)\r\n        {\r\n            marque[ligne][colonne]=0;\r\n        }\r\n    }\r\n\r\n    if(kase[bfs->case_de_referenceY][bfs->case_de_referenceX]->type==CHATEAU)\r\n    {\r\n        for(ligne=bfs->case_de_referenceY;ligne<bfs->case_de_referenceY+CHATEAU_H;ligne++)\r\n        {\r\n            for(colonne=bfs->case_de_referenceX;colonne<bfs->case_de_referenceX+CHATEAU_W;colonne++)\r\n            {\r\n                tester_voisins(kase,ligne,colonne,longueurs,marque,file);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    if(kase[bfs->case_de_referenceY][bfs->case_de_referenceX]->type==CASERNE)\r\n    {\r\n        for(ligne=bfs->case_de_referenceY;ligne<bfs->case_de_referenceY+CASERNE_H;ligne++)\r\n        {\r\n            for(colonne=bfs->case_de_referenceX;colonne<bfs->case_de_referenceX+CASERNE_W;colonne++)\r\n            {\r\n                tester_voisins(kase,ligne,colonne,longueurs,marque,file);\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    if(kase[bfs->case_de_referenceY][bfs->case_de_referenceX]->type==CENTRALE)\r\n    {\r\n        for(ligne=bfs->case_de_referenceY;ligne<bfs->case_de_referenceY+CENTRALE_H;ligne++)\r\n        {\r\n            for(colonne=bfs->case_de_referenceX;colonne<bfs->case_de_referenceX+CENTRALE_W;colonne++)\r\n            {\r\n                tester_voisins(kase,ligne,colonne,longueurs,marque,file);\r\n\r\n            }\r\n        }\r\n    }\r\n    while(!file_vide(file))\r\n    {\r\n        temp=file_defiler(file);\r\n        ligne=((t_route*)temp->elem)->case_de_referenceY;\r\n        colonne=((t_route*)temp->elem)->case_de_referenceX;\r\n        tester_voisins(kase,ligne,colonne,longueurs,marque,file);\r\n    }\r\n    free(file); // free et non pas file_detruire car il ne faut pas détruire les éléments de la file, qui sont directement\r\n    // des éléments (des cases) de notre terrain !\r\n    return longueurs;\r\n}\r\n\r\nvoid tester_voisins(t_case*** kase,int ligne,int colonne,int* longueurs,int marque[NB_CASES_LIG][NB_CASES_COL],t_file* file)\r\n{\r\n    if(ligne>0)\r\n    {\r\n        if(marque[ligne-1][colonne]==0)\r\n        {\r\n            if(kase[ligne-1][colonne]->type==ROUTE)\r\n            {\r\n                file_enfiler(file,kase[ligne-1][colonne]);\r\n                marque[ligne-1][colonne]=marque[ligne][colonne]+1;\r\n            }\r\n            if(kase[ligne-1][colonne]->type==HABITATION)\r\n            {\r\n                if((longueurs[((t_habitation*) kase[ligne-1][colonne]->elem)->indice]>marque[ligne][colonne])||(longueurs[((t_habitation*) kase[ligne-1][colonne]->elem)->indice]==0))\r\n                {\r\n                    longueurs[((t_habitation*) kase[ligne-1][colonne]->elem)->indice]=marque[ligne][colonne];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if(ligne<NB_CASES_LIG-1)\r\n    {\r\n        if(marque[ligne+1][colonne]==0)\r\n        {\r\n            if(kase[ligne+1][colonne]->type==ROUTE)\r\n            {\r\n                file_enfiler(file,kase[ligne+1][colonne]);\r\n                marque[ligne+1][colonne]=marque[ligne][colonne]+1;\r\n            }\r\n            if(kase[ligne+1][colonne]->type==HABITATION)\r\n            {\r\n                if((longueurs[((t_habitation*) kase[ligne+1][colonne]->elem)->indice]>marque[ligne][colonne])||(longueurs[((t_habitation*) kase[ligne+1][colonne]->elem)->indice]==0))\r\n                {\r\n                    longueurs[((t_habitation*) kase[ligne+1][colonne]->elem)->indice]=marque[ligne][colonne];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if(colonne<NB_CASES_COL-1)\r\n    {\r\n        if(marque[ligne][colonne+1]==0)\r\n        {\r\n            if(kase[ligne][colonne+1]->type==ROUTE)\r\n            {\r\n                file_enfiler(file,kase[ligne][colonne+1]);\r\n                marque[ligne][colonne+1]=marque[ligne][colonne]+1;\r\n            }\r\n            if(kase[ligne][colonne+1]->type==HABITATION)\r\n            {\r\n                if((longueurs[((t_habitation*) kase[ligne][colonne+1]->elem)->indice]>marque[ligne][colonne])||(longueurs[((t_habitation*) kase[ligne][colonne+1]->elem)->indice]==0))\r\n                {\r\n                    longueurs[((t_habitation*) kase[ligne][colonne+1]->elem)->indice]=marque[ligne][colonne];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if(colonne>0)\r\n    {\r\n        if(marque[ligne][colonne-1]==0)\r\n        {\r\n            if(kase[ligne][colonne-1]->type==ROUTE)\r\n            {\r\n                file_enfiler(file,kase[ligne][colonne-1]);\r\n                marque[ligne][colonne-1]=marque[ligne][colonne]+1;\r\n            }\r\n            if(kase[ligne][colonne-1]->type==HABITATION)\r\n            {\r\n                if((longueurs[((t_habitation*) kase[ligne][colonne-1]->elem)->indice]>marque[ligne][colonne])||(longueurs[((t_habitation*) kase[ligne][colonne-1]->elem)->indice]==0))\r\n                {\r\n                    longueurs[((t_habitation*) kase[ligne][colonne-1]->elem)->indice]=marque[ligne][colonne];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n/////////////////info.c////////////////////////\r\nt_infos * infos_creer()\r\n{\r\n\r\n    t_infos* nouv;\r\n    //allocation mémoire pour cette instance\r\n    nouv=(t_infos*)malloc(1*sizeof(t_infos));\r\n    //On en profite pour remplir directement les champs de l'instance\r\n    //Car ils sont définis en DUR par le developeur\r\n    nouv->x=COORDX1;\r\n    nouv->y=COORDY1;\r\n\r\n    nouv->isCatch=0;\r\n    return nouv;\r\n}\r\n\r\nvoid info_afficher(t_editeur* ed)\r\n{\r\n    int x,y;\r\n    x = ed->info->x;\r\n    y = ed->info->y;\r\n    rectfill(page, x, y, x+695, y+45, COUL_FOND);\r\n    rect(page, x, y-20, x+695, y+45, COUL_BORD);\r\n    /***** il faudra aussi rajouter les variables du style: argent, nombre d'habitants etc..*****/\r\n    textprintf_ex(page,font,x+12,y+10,makecol(255,255,255),-1,\"Nombre habitants: %d\",ed->maville->nb_habitants);\r\n    textprintf_ex(page,font,x+400,y+10,makecol(82,143,118),-1,\"Argent: %d ECEFlouz\",ed->maville->argent);\r\n    //textprintf_ex(page,font,x+400,y+10,makecol(255,255,255),-1,\"Temps de jeu: %d:%d:%.0f\",ed->maville->temps_de_jeu->heures,ed->maville->temps_de_jeu->minutes,ed->maville->temps_de_jeu->secondes);\r\n    textprintf_ex(page,font,x+12,y+30,makecol(255,228,54),-1,\"Elec dispo:%d/%d\",ed->maville->qte_elec.capacite_disponible,ed->maville->qte_elec.capacite_max);\r\n    textprintf_ex(page,font,x+400,y+30,makecol(0,0,255),-1,\"Eau dispo:%d/%d\",ed->maville->qte_eau.capacite_disponible,ed->maville->qte_eau.capacite_max);\r\n    //if(ed->maville->pause == PAUSE_ACTIVEE) textprintf_ex(page,font,700,40,makecol(0,0,0),-1,\"PAUSE ACTIVEE\");\r\n}\r\n\r\nvoid info_drag(t_editeur* ed)\r\n{\r\n\r\n\r\n    if (mouse_x >= ed->info->x && mouse_x <=  ed->info->x + 695 && mouse_y <=  ed->info->y && mouse_y >=  ed->info->y - 20)\r\n    {\r\n        rectfill(page,  ed->info->x,  ed->info->y-20,  ed->info->x+695,  ed->info->y, COUL_BORD);\r\n        if (mouse_b&1) {\r\n            ed->boite_a_outils->bouton_choisi = -1; // Si clic-droit alors on réinitialise le bouton choisi\r\n            ed->info->isCatch = 1;\r\n            //printf(\"%d\", boiteaoutils->isCatch);\r\n\r\n        }\r\n    }\r\n\r\n    if ( ed->info->isCatch==1) {\r\n        ed->info->x = mouse_x-695/2;\r\n        if (mouse_y + 10 >= 20) {\r\n            ed->info->y = mouse_y + 10;\r\n        }\r\n        else {\r\n            ed->info->y = 20;\r\n        }\r\n        //boiteaoutils_afficher(boiteaoutils);\r\n    }\r\n\r\n    if (mouse_b&1)\r\n    { ed->info->isCatch = 0;}\r\n\r\n\r\n\r\n}\r\n\r\n/////////////////boitaoutil.c////////////////////////\r\nt_boite_a_outils* boiteaoutils_creer()\r\n{\r\n    int i,j,cpt=0;\r\n    //déclaration d'une instance boite à outil\r\n    t_boite_a_outils* nouv;\r\n    //allocation mémoire pour cette instance\r\n    nouv=(t_boite_a_outils*)malloc(1*sizeof(t_boite_a_outils));\r\n    //On en profite pour remplir directement les champs de l'instance\r\n    //Car ils sont définis en DUR par le developeur\r\n    nouv->x=COORDX;\r\n    nouv->y=COORDY;\r\n\r\n    nouv->bouton_choisi = -1;\r\n    //On charge les images (outil%d.bmp)\r\n    boiteaoutils_chargerimages(nouv);\r\n    //on rempli la matrice MATACTION qui va définir\r\n    //le comportement de l'utilisateur dans le jeu\r\n    for(i=0;i<NB_BOUTONS_H;i++)\r\n    {\r\n        for(j=0;j<NB_BOUTONS_W;j++)\r\n        {\r\n            nouv->matbouton[i][j]=cpt;\r\n            cpt++;\r\n        }\r\n    }\r\n    return nouv;\r\n}\r\n\r\nvoid boiteaoutils_chargerimages(t_boite_a_outils* boiteaoutils)\r\n{\r\n    int i,j,nb=0;\r\n    char img_off[TAILLE_CHAINE];\r\n    char img_on[TAILLE_CHAINE];\r\n    //Pour chaque case de la boite à outil, on va charger l'image correspondante\r\n    //NB:on effectue cette action 1 fois, en début de programme, afin de ne pas toujours charger les images\r\n    for(i=0;i<NB_BOUTONS_H;i++)\r\n    {\r\n        for(j=0;j<NB_BOUTONS_W;j++)\r\n        {\r\n            sprintf(img_off,\"fichiers/images/boite_a_outils/outil_off%d.bmp\",nb);\r\n            sprintf(img_on,\"fichiers/images/boite_a_outils/outil_on%d.bmp\",nb);\r\n            boiteaoutils->img_bouton_off[i][j]=chargerImage(img_off);\r\n            boiteaoutils->img_bouton_on[i][j]=chargerImage(img_on);\r\n            nb++;\r\n        }\r\n    }\r\n}\r\n\r\nvoid boiteaoutils_drag(t_boite_a_outils* boiteaoutils)\r\n{\r\n\r\n\r\n    if (mouse_x >= boiteaoutils->x && mouse_x <= boiteaoutils->x + NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+75 && mouse_y <= boiteaoutils->y && mouse_y >= boiteaoutils->y - 20)\r\n    {\r\n        rectfill(page, boiteaoutils->x, boiteaoutils->y-20, boiteaoutils->x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+75, boiteaoutils->y, COUL_BORD);\r\n        if (mouse_b&1) {\r\n            boiteaoutils->bouton_choisi = -1; // Si clic-droit alors on réinitialise le bouton choisi\r\n            boiteaoutils->isCatch = 1;\r\n            //printf(\"%d\", boiteaoutils->isCatch);\r\n\r\n        }\r\n    }\r\n\r\n    if (boiteaoutils->isCatch==1) {\r\n        boiteaoutils->x = mouse_x-(NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS))/2;\r\n        if (mouse_y + 10 >= 20) {\r\n            boiteaoutils->y = mouse_y + 10;\r\n        }\r\n        else {\r\n            boiteaoutils->y = 20;\r\n        }\r\n        //boiteaoutils_afficher(boiteaoutils);\r\n    }\r\n\r\n    if (mouse_b&1)\r\n    {boiteaoutils->isCatch = 0;}\r\n\r\n\r\n\r\n}\r\n\r\nvoid boiteaoutils_afficher(t_boite_a_outils* boiteaoutils)\r\n{\r\n    int x,y;\r\n    int i,j,b;\r\n    //boiteaoutils->isCatch=0;\r\n\r\n\r\n    x = boiteaoutils->x;\r\n    y = boiteaoutils->y;\r\n    //créer le rectangle de la boite à outil\r\n    rectfill(page, x, y-20, x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+75, y+NB_BOUTONS_H*(LARGEUR_CASE+TAILLE_BORDS), COUL_FOND);\r\n    rect(page, x, y-20, x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+75, y+NB_BOUTONS_H*(LARGEUR_CASE+TAILLE_BORDS), COUL_BORD);\r\n\r\n    textprintf_ex(page,font,x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+2,y+26,makecol(0,0,0),-1,\"Route\");\r\n    textprintf_ex(page,font,x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+2,y+78,makecol(0,0,0),-1,\"Maison\");\r\n    textprintf_ex(page,font,x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+2,y+130,makecol(0,0,0),-1,\"Chateau\");\r\n    textprintf_ex(page,font,x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+2,y+182,makecol(0,0,0),-1,\"Centrale\");\r\n    textprintf_ex(page,font,x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+2,y+234,makecol(0,0,0),-1,\"Caserne\");\r\n    textprintf_ex(page,font,x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+2,y+286,makecol(0,0,0),-1,\"Vu sol\");\r\n    textprintf_ex(page,font,x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+2,y+338,makecol(0,0,0),-1,\"Vu eau\");\r\n    textprintf_ex(page,font,x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+2,y+390,makecol(0,0,0),-1,\"Vu elec\");\r\n    textprintf_ex(page,font,x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+2,y+442,makecol(0,0,0),-1,\"Pause\");\r\n    textprintf_ex(page,font,x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+2,y+489,makecol(0,0,0),-1,\"Sauv\");\r\n\r\n    //la remplir avec les images\r\n    for(i=0;i<NB_BOUTONS_H;i++) {\r\n        for (j = 0; j < NB_BOUTONS_W; j++) {\r\n            if (boiteaoutils->bouton_choisi != boiteaoutils->matbouton[i][j]) {\r\n                draw_sprite(page, boiteaoutils->img_bouton_off[i][j], x, y);\r\n            } else {\r\n                draw_sprite(page, boiteaoutils->img_bouton_on[i][j], x, y);\r\n            }\r\n            for (b = 0; b < TAILLE_BORDS; b++) {\r\n                rect(page, x - b, y - b, x + LARGEUR_CASE + b+75, y + LARGEUR_CASE + b, COUL_BORD);\r\n            }\r\n            x = x + LARGEUR_CASE + TAILLE_BORDS;\r\n        }\r\n        x = boiteaoutils->x;\r\n        y = y + LARGEUR_CASE + TAILLE_BORDS;\r\n    }\r\n}\r\n\r\n/////////////////case.c////////////////////////\r\n\r\nt_case* case_allouer()\r\n{\r\n    t_case* nouv;\r\n    nouv=malloc(sizeof(t_case));\r\n\r\n    nouv->elem=NULL;\r\n    nouv->type=VIDE;\r\n\r\n    return nouv;\r\n}\r\n\r\nint case_libre(t_case* kase)\r\n{\r\n    int libre=1;\r\n\r\n    if(kase->type!=VIDE)\r\n    {\r\n        libre=0;\r\n    }\r\n    return libre;\r\n}\r\n\r\n/////////////////caserne.c////////////////////////\r\nt_caserne* caserne_creer()\r\n{\r\n    t_caserne* nouv;\r\n    nouv=malloc(sizeof(t_caserne));\r\n\r\n    nouv->temps_de_rechargement=0;\r\n    nouv->occupe=0;\r\n    nouv->case_de_referenceX = 0;\r\n    nouv->case_de_referenceY = 0;\r\n\r\n    return nouv;\r\n}\r\n\r\nint caserne_place_libre(int x,int y,t_case*** kase)\r\n{\r\n    int i,j;\r\n    int libre=1;\r\n    if(!caserne_depassement_matrice(x,y))\r\n    {\r\n        for(i=x;i<x+CASERNE_W;i++)\r\n        {\r\n            for(j=y;j<y+CASERNE_H;j++)\r\n            {\r\n                if(kase[j][i]->type!=VIDE)\r\n                {\r\n                    libre=0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else libre=0;\r\n    return libre;\r\n}\r\n\r\nint caserne_depassement_matrice(int colonne,int ligne)\r\n{\r\n    int depasse=1;\r\n    if((colonne>=0)&&(colonne<NB_CASES_COL-(CASERNE_W-1))&&(ligne>=0)&&(ligne<NB_CASES_LIG-(CASERNE_H-1)))\r\n    {\r\n        depasse=0;\r\n    }\r\n    return depasse;\r\n}\r\n\r\n/////////////////centrale.c////////////////////////\r\nt_centrale* centrale_creer()\r\n{\r\n    t_centrale* nouv;\r\n    nouv=malloc(sizeof(t_centrale));\r\n\r\n    nouv->capacite.capacite_disponible = CAPACITE_CENTRALE;\r\n    nouv->capacite.capacite_max = CAPACITE_CENTRALE;\r\n    nouv->case_de_referenceX = 0;\r\n    nouv->case_de_referenceY = 0;\r\n    nouv->id_centrale.caseX = -1;\r\n    nouv->id_centrale.caseX = -1;\r\n    return nouv;\r\n}\r\n\r\nint centrale_place_libre(int col,int lig,t_case*** kase)\r\n{\r\n    int i,j;\r\n    int libre=1;\r\n    if(!centrale_depassement_matrice(col,lig))\r\n    {\r\n        for(i=lig;i<lig+CENTRALE_H;i++)\r\n        {\r\n            for(j=col;j<col+CENTRALE_W;j++)\r\n            {\r\n                if(kase[i][j]->type!=VIDE)\r\n                {\r\n                    libre=0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else libre=0;\r\n    return libre;\r\n}\r\n\r\nint centrale_depassement_matrice(int colonne,int ligne)\r\n{\r\n    int depasse=1;\r\n    if((colonne>=0)&&(colonne<=NB_CASES_COL-CENTRALE_W)&&(ligne>=0)&&(ligne<=NB_CASES_LIG-CENTRALE_H))\r\n    {\r\n        depasse=0;\r\n    }\r\n    return depasse;\r\n}\r\n\r\n/////////////////chateau.c////////////////////////\r\nt_chateau* chateau_creer()\r\n{\r\n    t_chateau* nouv;\r\n    nouv=malloc(sizeof(t_chateau));\r\n\r\n    nouv->capacite.capacite_disponible = CAPACITE_CHATEAU;\r\n    nouv->capacite.capacite_max = CAPACITE_CHATEAU;\r\n    nouv->case_de_referenceX = 0;\r\n    nouv->case_de_referenceY = 0;\r\n    nouv->id_chateau.caseX = -1;\r\n    nouv->id_chateau.caseY = -1;\r\n\r\n    return nouv;\r\n}\r\n\r\nint chateau_place_libre(int col,int lig,t_case*** kase)\r\n{\r\n    int i,j;\r\n    int libre=1;\r\n    if(!chateau_depassement_matrice(col,lig))\r\n    {\r\n        for(i=col;i<col+CHATEAU_W;i++)\r\n        {\r\n            for(j=lig;j<lig+CHATEAU_H;j++)\r\n            {\r\n                if(kase[j][i]->type!=VIDE)\r\n                {\r\n                    libre=0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else libre=0;\r\n    return libre;\r\n}\r\n\r\nint chateau_depassement_matrice(int colonne,int ligne)\r\n{\r\n    int depasse=1;\r\n    if((colonne>=0)&&(colonne<=NB_CASES_COL-CHATEAU_W)&&(ligne>=0)&&(ligne<=NB_CASES_LIG-CHATEAU_H))\r\n    {\r\n        depasse=0;\r\n    }\r\n    return depasse;\r\n}\r\n\r\nint chateau_distribuer(t_chateau* chateau,t_habitation* habitation)\r\n{\r\n    int eau_distribuee=0,quantitee,i,eau_distrib;\r\n    int index = 0;\r\n\r\n    for(i=0;i<FOURNISSEUR_MAX;i++)\r\n    {\r\n        eau_distribuee+=habitation->chateaux_fournisseurs[i].qte_eau_distribuee;\r\n    }\r\n\r\n//desert\r\n\r\n    if (habitation->case_de_referenceX >= 0/20 && habitation->case_de_referenceX <= 320/20 && habitation->case_de_referenceY >= (585-25)/20 && habitation->case_de_referenceY <=(725-25)/20)\r\n    {\r\n        quantitee=habitation_nbhabitants(habitation)+eau_distribuee+100;\r\n        printf(\"desert1\\n\");\r\n\r\n    }\r\n\r\n    else if (habitation->case_de_referenceX >= 0/20 && habitation->case_de_referenceX <= 120/20 && habitation->case_de_referenceY >= (25-25)/20 && habitation->case_de_referenceY <=(725-25)/20)\r\n    {\r\n        quantitee=habitation_nbhabitants(habitation)+eau_distribuee+100;\r\n        printf(\"desert2\\n\");\r\n    }\r\n\r\n    else if (habitation->case_de_referenceX >= 0/20 && habitation->case_de_referenceX <= 200/20 && habitation->case_de_referenceY >= (85-25)/20 && habitation->case_de_referenceY <=(725-25)/20)\r\n    {\r\n        quantitee=habitation_nbhabitants(habitation)+eau_distribuee+100;\r\n        printf(\"desert3\\n\");\r\n    }\r\n\r\n    else if (habitation->case_de_referenceX >= 0/20 && habitation->case_de_referenceX <= 240/20 && habitation->case_de_referenceY >= (285-25)/20 && habitation->case_de_referenceY <=(725-25)/20)\r\n    {\r\n        quantitee=habitation_nbhabitants(habitation)+eau_distribuee+100;\r\n        printf(\"desert4\\n\");\r\n    }\r\n\r\n    else\r\n    {\r\n        quantitee=habitation_nbhabitants(habitation)-eau_distribuee;\r\n        printf(\"%d\\n\",quantitee);\r\n    }\r\n\r\n\r\n    if(chateau->capacite.capacite_disponible>=quantitee)\r\n    {\r\n        //////////////////////////////////////////////////////////////// on cherche l'indice du 1er chateau fournisseur\r\n        // qui n'a pas encore distribué d'eau\r\n        // (on cherche à savoir s'il reste une place dans\r\n        // le tableau des fournisseurs)\r\n        i=0;\r\n        do\r\n        {\r\n            eau_distrib= habitation->chateaux_fournisseurs[i].qte_eau_distribuee;\r\n            if(eau_distrib == 0) index = i;\r\n            i++;\r\n        }while(eau_distrib != 0 && i<FOURNISSEUR_MAX);\r\n        ///////////////////////////////////////////////////////////////\r\n        if(eau_distrib == 0) // si on a trouvé une place dans le tableau des fournisseurs, on alimente. sinon non.\r\n        {\r\n            habitation->chateaux_fournisseurs[index].qte_eau_distribuee=quantitee;\r\n            habitation->chateaux_fournisseurs[index].id_fournisseur.caseX =chateau->id_chateau.caseX;\r\n            habitation->chateaux_fournisseurs[index].id_fournisseur.caseY =chateau->id_chateau.caseY;\r\n            chateau->capacite.capacite_disponible-=quantitee;\r\n            habitation->eau=1;\r\n        }\r\n        else // on n'a pas trouvé de place, on n'alimente pas, donc la quantité distribuée est nulle\r\n        {\r\n            quantitee=0;\r\n        }\r\n    }\r\n    else if(chateau->capacite.capacite_disponible<quantitee)\r\n    {\r\n        //////////////////////////////////////////////////////////////// on cherche l'indice du 1er chateau fournisseur\r\n        // qui n'a pas encore distribué d'eau\r\n        // (on cherche à savoir s'il reste une place dans\r\n        // le tableau des fournisseurs)\r\n        i=0;\r\n        do\r\n        {\r\n            eau_distrib= habitation->chateaux_fournisseurs[i].qte_eau_distribuee;\r\n            if(eau_distrib == 0)\r\n            {\r\n                index = i;\r\n            }\r\n            i++;\r\n        }while(eau_distrib != 0 && i<FOURNISSEUR_MAX);\r\n        ///////////////////////////////////////////////////////////////\r\n        if(eau_distrib == 0) // si on a trouvé une place dans le tableau des fournisseurs, on alimente. sinon non.\r\n        {\r\n            quantitee =chateau->capacite.capacite_disponible;\r\n            chateau->capacite.capacite_disponible=0;\r\n\r\n            habitation->chateaux_fournisseurs[index].qte_eau_distribuee=quantitee;\r\n            habitation->chateaux_fournisseurs[index].id_fournisseur=chateau->id_chateau;\r\n        }\r\n        else // on n'a pas trouvé de place, on n'alimente pas, donc la quantité distribuée est nulle\r\n        {\r\n            quantitee = 0;\r\n        }\r\n    }\r\n    return quantitee;\r\n}\r\n\r\n/////////////////collection_casernes.c////////////////////////\r\nt_collection_casernes* collection_casernes_creer()\r\n{\r\n    t_collection_casernes* nouv;\r\n    nouv=malloc(sizeof(t_collection_casernes));\r\n    nouv->taille_actuelle=0;\r\n    nouv->taille_max=TAILLE_INITIALE_COLLECTION;\r\n    nouv->caserne=malloc(nouv->taille_max*sizeof(t_caserne*));\r\n    return nouv;\r\n}\r\n\r\nvoid collection_casernes_ajouter_caserne(t_collection_casernes* collection_casernes,t_caserne* new_caserne)\r\n{\r\n    if(collection_casernes->taille_actuelle==collection_casernes->taille_max)\r\n    {\r\n        collection_casernes->taille_max=3*collection_casernes->taille_max/2;\r\n        collection_casernes->caserne=realloc(collection_casernes->caserne,collection_casernes->taille_max*sizeof(t_caserne*));\r\n    }\r\n    collection_casernes->caserne[collection_casernes->taille_actuelle]=new_caserne;\r\n    collection_casernes->taille_actuelle++;\r\n}\r\n\r\nint** collection_casernes_tableau_longueurs(t_collection_casernes* collection_casernes,t_case*** kase,t_bfs* bfs,t_collection_habitation* collection_habitation)\r\n{\r\n    int i;\r\n    int** longueurs_casernes_maisons;\r\n\r\n    longueurs_casernes_maisons=malloc(collection_casernes->taille_actuelle*sizeof(int*));\r\n\r\n    bfs->ordre=collection_habitation->taille_actuelle;\r\n    for(i=0; i<collection_casernes->taille_actuelle; i++)\r\n    {\r\n        bfs->case_de_referenceX=collection_casernes->caserne[i]->case_de_referenceX;\r\n        bfs->case_de_referenceY=collection_casernes->caserne[i]->case_de_referenceY;\r\n        longueurs_casernes_maisons[i]=recherchepluscourtchemin(bfs,kase);\r\n    }\r\n    return longueurs_casernes_maisons;\r\n}\r\n\r\nvoid collection_casernes_proteger(t_collection_casernes* collection_casernes,t_collection_habitation* collection_habitation,int** longueurs)\r\n{\r\n    int i,j;\r\n    for(i=0;i<collection_habitation->taille_actuelle;i++)\r\n    {\r\n        for(j=0;j<collection_casernes->taille_actuelle;j++)\r\n        {\r\n            if((longueurs[j][i]<RAYON_INFLUENCE_CASERNE)&&(longueurs[j][i]))\r\n            {\r\n                collection_habitation->habitation[i]->protegee=PROTEGEE;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/////////////////collection_centrales.c////////////////////////\r\nt_collection_centrale* collection_centrale_creer()\r\n{\r\n    t_collection_centrale* nouv;\r\n    nouv=malloc(sizeof(t_collection_centrale));\r\n    nouv->taille_actuelle=0;\r\n    nouv->taille_max=TAILLE_INITIALE_COLLECTION;\r\n    nouv->centrale=malloc(nouv->taille_max*sizeof(t_centrale*));\r\n    return nouv;\r\n}\r\n\r\nvoid collection_centrale_ajouter_centrale(t_collection_centrale* collection_centrale,t_centrale* new_centrale)\r\n{\r\n    if(collection_centrale->taille_actuelle==collection_centrale->taille_max)\r\n    {\r\n        collection_centrale->taille_max=3*collection_centrale->taille_max/2;\r\n        collection_centrale->centrale=realloc(collection_centrale->centrale,collection_centrale->taille_max*sizeof(t_centrale*));\r\n    }\r\n    collection_centrale->centrale[collection_centrale->taille_actuelle]=new_centrale;\r\n    collection_centrale->taille_actuelle++;\r\n}\r\n\r\nvoid collection_centrale_distribuer(t_collection_centrale* collection_centrale,t_collection_habitation* collection_habitation,int** longueurs)\r\n{\r\n    int i=0,j=0;\r\n    int quantitee;\r\n\r\n    for(i=0; i<collection_centrale->taille_actuelle; i++)\r\n    {\r\n        for(j=0; j<collection_habitation->taille_actuelle; j++)\r\n        {\r\n            if((collection_habitation->habitation[j]->electricite==0)&&(longueurs[i][j]!=0))\r\n            {\r\n                //glace\r\n\r\n                if (collection_habitation->habitation[j]->case_de_referenceX >= 600/20 && collection_habitation->habitation[j]->case_de_referenceX <= 900/20 && collection_habitation->habitation[j]->case_de_referenceY >= (25-25)/20 && collection_habitation->habitation[j]->case_de_referenceY <=(165-25)/20)\r\n                {\r\n                    quantitee=habitation_nbhabitants(collection_habitation->habitation[j])+100;\r\n                    printf(\"glace1\\n\");\r\n                }\r\n\r\n                else if (collection_habitation->habitation[j]->case_de_referenceX >= 800/20 && collection_habitation->habitation[j]->case_de_referenceX <= 900/20 && collection_habitation->habitation[j]->case_de_referenceY >= (25-25)/20 && collection_habitation->habitation[j]->case_de_referenceY <=(345-25)/20)\r\n                {\r\n                    quantitee=habitation_nbhabitants(collection_habitation->habitation[j])+100;\r\n                    printf(\"glace2\\n\");\r\n                }\r\n\r\n                else if (collection_habitation->habitation[j]->case_de_referenceX >= 660/20 && collection_habitation->habitation[j]->case_de_referenceX <= 900/20 && collection_habitation->habitation[j]->case_de_referenceY >= (25-25)/20 && collection_habitation->habitation[j]->case_de_referenceY <=(205-25)/20)\r\n                {\r\n                    quantitee=habitation_nbhabitants(collection_habitation->habitation[j])+100;\r\n                    printf(\"glace3\\n\");\r\n                }\r\n\r\n                else if (collection_habitation->habitation[j]->case_de_referenceX >= 860/20 && collection_habitation->habitation[j]->case_de_referenceX <= 900/20 && collection_habitation->habitation[j]->case_de_referenceY >= (25-25)/20 && collection_habitation->habitation[j]->case_de_referenceY <=(385-25)/20)\r\n                {\r\n                    quantitee=habitation_nbhabitants(collection_habitation->habitation[j])+100;\r\n                    printf(\"glace4\\n\");\r\n                }\r\n\r\n                else if (collection_habitation->habitation[j]->case_de_referenceX >= 760/20 && collection_habitation->habitation[j]->case_de_referenceX <= 900/20 && collection_habitation->habitation[j]->case_de_referenceY >= (245-25)/20 && collection_habitation->habitation[j]->case_de_referenceY <=(285-25)/20)\r\n                {\r\n                    quantitee=habitation_nbhabitants(collection_habitation->habitation[j])+100;\r\n                    printf(\"glace5\\n\");\r\n\r\n                }\r\n                else\r\n                {\r\n                    quantitee=habitation_nbhabitants(collection_habitation->habitation[j]);\r\n                    printf(\"%d\\n\",quantitee);\r\n                }\r\n                //quantitee=habitation_nbhabitants(collection_habitation->habitation[j]); ///retourne le nombre d'habitant en fonction du stade de développement\r\n                if(collection_centrale->centrale[i]->capacite.capacite_disponible>=quantitee)\r\n                {\r\n                    collection_habitation->habitation[j]->id_centrale_fournisseuse.caseX = collection_centrale->centrale[i]->id_centrale.caseX; // on recopie l'ID de la centrale\r\n                    collection_habitation->habitation[j]->id_centrale_fournisseuse.caseY = collection_centrale->centrale[i]->id_centrale.caseY; // on recopie l'ID de la centrale\r\n                    collection_centrale->centrale[i]->capacite.capacite_disponible-=quantitee;\r\n                    collection_habitation->habitation[j]->electricite=1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint collection_centrale_elec_disponible(t_collection_centrale* collection_centrale)\r\n{\r\n    int elec_totale_dispo = 0;\r\n    int i;\r\n    for(i=0;i<collection_centrale->taille_actuelle;i++)\r\n    {\r\n        elec_totale_dispo += collection_centrale->centrale[i]->capacite.capacite_disponible;\r\n    }\r\n    return elec_totale_dispo;\r\n}\r\n\r\nint** collection_centrale_tableau_longueurs(t_collection_centrale* collection_centrale,t_case*** kase,t_bfs* bfs,t_collection_habitation* collection_habitation)\r\n{\r\n    int i;\r\n    int** longueurs_centrales_maisons;\r\n\r\n    longueurs_centrales_maisons=malloc(collection_centrale->taille_actuelle*sizeof(int*));\r\n\r\n    bfs->ordre=collection_habitation->taille_actuelle;\r\n    for(i=0; i<collection_centrale->taille_actuelle; i++)\r\n    {\r\n        bfs->case_de_referenceX=collection_centrale->centrale[i]->case_de_referenceX;\r\n        bfs->case_de_referenceY=collection_centrale->centrale[i]->case_de_referenceY;\r\n        longueurs_centrales_maisons[i]=recherchepluscourtchemin(bfs,kase);\r\n    }\r\n    return longueurs_centrales_maisons;\r\n}\r\n\r\nint* collection_centrale_tableau_capacite(t_collection_centrale* collection_centrale)\r\n{\r\n    int* capacite_centrale;\r\n    int i;\r\n    capacite_centrale=malloc(collection_centrale->taille_actuelle*sizeof(int));\r\n    for(i=0;i<collection_centrale->taille_actuelle;i++)\r\n    {\r\n        capacite_centrale[i]=collection_centrale->centrale[i]->capacite.capacite_disponible;\r\n    }\r\n    return capacite_centrale;\r\n}\r\n\r\n/////////////////collection_chateau.c////////////////////////\r\nt_collection_chateau* collection_chateau_creer()\r\n{\r\n    t_collection_chateau* nouv;\r\n    nouv=malloc(sizeof(t_collection_chateau));\r\n    nouv->taille_actuelle=0;\r\n    nouv->taille_max=TAILLE_INITIALE_COLLECTION;\r\n    nouv->chateau=malloc(nouv->taille_max*sizeof(t_chateau*));\r\n    return nouv;\r\n}\r\n\r\nvoid collection_chateau_ajouter_chateau(t_collection_chateau* collection_chateau,t_chateau* new_chateau)\r\n{\r\n    if(collection_chateau->taille_actuelle==collection_chateau->taille_max)\r\n    {\r\n        collection_chateau->taille_max=3*collection_chateau->taille_max/2;\r\n        collection_chateau->chateau=realloc(collection_chateau->chateau,collection_chateau->taille_max*sizeof(t_chateau*));\r\n    }\r\n    collection_chateau->chateau[collection_chateau->taille_actuelle]=new_chateau;\r\n    collection_chateau->taille_actuelle++;\r\n}\r\n\r\nint** collection_chateau_tableau_longueurs(t_collection_chateau* collection_chateau,t_case*** kase,t_bfs* bfs,t_collection_habitation* collection_habitation)\r\n{\r\n    int i;\r\n    int** longueurs_chateaux_maisons;\r\n\r\n    longueurs_chateaux_maisons=malloc(collection_chateau->taille_actuelle*sizeof(int*));\r\n\r\n    bfs->ordre=collection_habitation->taille_actuelle;\r\n    for(i=0; i<collection_chateau->taille_actuelle; i++)\r\n    {\r\n        bfs->case_de_referenceX=collection_chateau->chateau[i]->case_de_referenceX;\r\n        bfs->case_de_referenceY=collection_chateau->chateau[i]->case_de_referenceY;\r\n        longueurs_chateaux_maisons[i]=recherchepluscourtchemin(bfs,kase);\r\n    }\r\n    return longueurs_chateaux_maisons;\r\n}\r\n\r\nvoid collection_chateau_distribuer(t_collection_chateau* collection_chateau,t_collection_habitation* collection_habitation,int** longueurs_chateaux_habitations)\r\n{\r\n    int i=0;\r\n    int eau_dispo;\r\n    int taille1,taille2,compteur,j,compteur2,k,l;\r\n    int mini,distributeur=0,receveur;\r\n    if((collection_habitation->taille_actuelle!=0)&&(collection_chateau->taille_actuelle!=0))\r\n    {\r\n        //pour toutes les maisons\r\n        while(i<collection_habitation->taille_actuelle)\r\n        {//on cherche TOUTES les plus grosses\r\n            compteur=i;\r\n            taille1=collection_habitation->habitation[i]->stade;\r\n            taille2=collection_habitation->habitation[i]->stade;\r\n            while(taille1==taille2)\r\n            {\r\n                compteur++;\r\n                if(compteur<collection_habitation->taille_actuelle) taille2=collection_habitation->habitation[compteur]->stade;\r\n                else taille2=INFINI;\r\n            }\r\n            //Pour CHACUNE de ces habitations (il y en a compteur-1)\r\n            for(l=i;l<compteur;l++)\r\n            {\r\n                mini=INFINI;\r\n                receveur=-1;\r\n                for(k=0;k<collection_chateau->taille_actuelle;k++)\r\n                {\r\n                    for(j=i;j<compteur;j++)\r\n                    {\r\n                        if((longueurs_chateaux_habitations[k][j]!=0)&&(longueurs_chateaux_habitations[k][j]<mini)&&(collection_habitation->habitation[j]->electricite==1)&&(collection_habitation->habitation[j]->eau!=1))\r\n                        {\r\n                            mini=longueurs_chateaux_habitations[k][j];\r\n                            receveur=j;\r\n                        }\r\n                    }\r\n                }\r\n                if(receveur!=-1)\r\n                {\r\n                    //on compte l'eau disponible sur le réseau\r\n                    eau_dispo=0;\r\n                    for(compteur2=0;compteur2<collection_chateau->taille_actuelle;compteur2++)\r\n                    {\r\n                        if(longueurs_chateaux_habitations[compteur2][receveur]!=0)\r\n                        {\r\n                            eau_dispo+=collection_chateau->chateau[compteur2]->capacite.capacite_disponible;\r\n                        }\r\n                    }//TANT que l'habitation n'est pas alimenté et que l'eau disponible n'est pas épuisée et qu'on a pas atteint la limite des fournisseur\r\n                    while((collection_habitation->habitation[receveur]->eau!=1)&&(eau_dispo>0)&&(collection_habitation->habitation[receveur]->chateaux_fournisseurs[FOURNISSEUR_MAX-1].qte_eau_distribuee==0))\r\n                    {\r\n                        //On recherche la centrale sur le réseau la plus proche\r\n                        mini=INFINI;\r\n                        for(compteur2=0;compteur2<collection_chateau->taille_actuelle;compteur2++)\r\n                        {\r\n                            if((longueurs_chateaux_habitations[compteur2][receveur]!=0)&&(longueurs_chateaux_habitations[compteur2][receveur]<mini)&&(collection_chateau->chateau[compteur2]->capacite.capacite_disponible!=0))\r\n                            {\r\n                                distributeur=compteur2;\r\n                                mini=longueurs_chateaux_habitations[compteur2][receveur];\r\n                            }\r\n                        }//on alimente l'habitation et on tient à jours la quantitee d'eau dispo\r\n                        eau_dispo-=chateau_distribuer(collection_chateau->chateau[distributeur],collection_habitation->habitation[receveur]);\r\n                    }\r\n                }\r\n\r\n            }\r\n            i=compteur;\r\n        }\r\n    }\r\n}\r\n\r\nint collection_chateau_eau_disponible(t_collection_chateau* collection_chateau)\r\n{\r\n    int eau_totale_dispo = 0;\r\n    int i;\r\n\r\n    for(i=0; i<collection_chateau->taille_actuelle; i++)\r\n    {\r\n        eau_totale_dispo = eau_totale_dispo + collection_chateau->chateau[i]->capacite.capacite_disponible;;\r\n    }\r\n\r\n    return eau_totale_dispo;\r\n}\r\n\r\nint* collection_chateau_tableau_capacite(t_collection_chateau* collection_chateau)\r\n{\r\n    int* capacite_chateau;\r\n    int i;\r\n    capacite_chateau=malloc(collection_chateau->taille_actuelle*sizeof(int));\r\n    for(i=0;i<collection_chateau->taille_actuelle;i++)\r\n    {\r\n        capacite_chateau[i]=collection_chateau->chateau[i]->capacite.capacite_disponible;\r\n    }\r\n    return capacite_chateau;\r\n}\r\n\r\n/////////////////collection_habitations.c////////////////////////\r\nt_collection_habitation* collection_habitation_creer()\r\n{\r\n    t_collection_habitation* nouv;\r\n    nouv=malloc(sizeof(t_collection_habitation));\r\n    nouv->taille_actuelle=0;\r\n    nouv->taille_max=TAILLE_INITIALE_COLLECTION;\r\n    nouv->habitation=malloc(nouv->taille_max*sizeof(t_habitation*));\r\n    return nouv;\r\n}\r\n\r\nvoid collection_habitation_trier(t_collection_habitation* collection_habitation)\r\n{\r\n    int i;\r\n    qsort(collection_habitation->habitation, collection_habitation->taille_actuelle, sizeof(t_habitation*),habitation_comparer);\r\n    for(i=0;i<collection_habitation->taille_actuelle;i++)\r\n    {\r\n        collection_habitation->habitation[i]->indice=i;\r\n    }\r\n}\r\n\r\nvoid collection_habitation_ajouter_habitation(t_collection_habitation* collection_habitation,t_habitation* new_habitation)\r\n{\r\n    if(collection_habitation->taille_actuelle==collection_habitation->taille_max)\r\n    {\r\n        collection_habitation->taille_max=3*collection_habitation->taille_max/2;\r\n        collection_habitation->habitation=realloc(collection_habitation->habitation,collection_habitation->taille_max*sizeof(t_habitation*));\r\n    }\r\n    collection_habitation->habitation[collection_habitation->taille_actuelle]=new_habitation;\r\n    collection_habitation->taille_actuelle++;\r\n}\r\n\r\nvoid collection_habitation_evolution(t_collection_habitation* collection_habitation,int mode, int* argent,int nb_chateaux,int nb_centrales,int** longueurs_chateaux,int** longueurs_centrales,int* capacite_chateaux,int* capacite_centrale)\r\n{\r\n    int i;\r\n    if(collection_habitation->taille_actuelle!=0)\r\n    {\r\n        for(i=0;i<collection_habitation->taille_actuelle;i++)\r\n        {\r\n            habitation_evoluer(collection_habitation->habitation[i],mode,argent,nb_chateaux,nb_centrales,longueurs_chateaux,longueurs_centrales,capacite_chateaux,capacite_centrale);\r\n        }\r\n    }\r\n}\r\n\r\nvoid collection_habitation_debut_tour(t_collection_habitation* collection_habitation, int* nb_habitants)\r\n{\r\n    int i;\r\n    for(i=0;i<collection_habitation->taille_actuelle;i++)\r\n    {\r\n        int l,alea;\r\n        collection_habitation->habitation[i]->eau =0;\r\n        collection_habitation->habitation[i]->electricite=0;\r\n        collection_habitation->habitation[i]->id_centrale_fournisseuse.caseX = -1;\r\n        collection_habitation->habitation[i]->id_centrale_fournisseuse.caseX = -1;\r\n        ///DECLARATION ALEATOIRE D'UN INCENDIE\r\n        if(collection_habitation->habitation[i]->stade>=STADE_CABANE)\r\n        {\r\n            if(!collection_habitation->habitation[i]->feu)\r\n            {\r\n                alea=rand()%PROBABILITE_INCENDIE+1;\r\n                if(alea==PROBABILITE_INCENDIE)\r\n                {\r\n                    collection_habitation->habitation[i]->feu=EN_FEU;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                collection_habitation->habitation[i]->feu+=1;\r\n            }\r\n        }\r\n        collection_habitation->habitation[i]->protegee=PAS_PROTEGEE;\r\n\r\n        for(l=0;l<FOURNISSEUR_MAX;l++)\r\n        {\r\n            collection_habitation->habitation[i]->chateaux_fournisseurs[l].qte_eau_distribuee=0;\r\n            collection_habitation->habitation[i]->chateaux_fournisseurs[l].id_fournisseur.caseX= -1;\r\n            collection_habitation->habitation[i]->chateaux_fournisseurs[l].id_fournisseur.caseY= -1;\r\n        }\r\n    }\r\n    collection_habitation_trier(collection_habitation);\r\n    *nb_habitants = collection_habitation_nombre_habitants(collection_habitation);\r\n}\r\n\r\nint collection_habitation_nombre_habitants(t_collection_habitation* collection_habitation)\r\n{\r\n    int nb_hab_total = 0;\r\n    int i;\r\n\r\n    for(i=0;i<collection_habitation->taille_actuelle;i++)\r\n    {\r\n        nb_hab_total = nb_hab_total + habitation_nbhabitants(collection_habitation->habitation[i]);\r\n    }\r\n\r\n    return nb_hab_total;\r\n}\r\n\r\n/////////////////compalleg.c////////////////////////\r\nBITMAP *page=NULL;\r\nint page_couleur_fond;\r\nchar bouton;\r\nchar touche;\r\nint mouse_click;\r\nint mouse_unclick;\r\nint key_press[KEY_MAX];\r\nint key_unpress[KEY_MAX];\r\nint mouse_depx;\r\nint mouse_depy;\r\n\r\nvoid initialiser_allegro(int w, int h)\r\n{\r\n    if (page) return;\r\n\r\n    COLOR_MAP global_trans_table;\r\n    PALETTE pal;\r\n\r\n    allegro_init();\r\n    install_keyboard();\r\n    set_keyboard_rate(0,0);\r\n    install_mouse();\r\n    install_sound(DIGI_AUTODETECT,MIDI_AUTODETECT,NULL); //////////// INDISPENSABLE!!\r\n\r\n    create_trans_table(&global_trans_table, pal, 128, 128, 128, NULL);\r\n\r\n    set_color_depth(desktop_color_depth());\r\n    if (set_gfx_mode(GFX_AUTODETECT_WINDOWED,w,h,0,0)!=0)\r\n    {\r\n        allegro_message(\"prb gfx mode\");\r\n        allegro_exit();\r\n        exit(EXIT_FAILURE);\r\n    }\r\n    changer_nom_fenetre(\"ECE City\");\r\n\r\n    if (get_color_depth() == 8)\r\n        color_map = &global_trans_table;\r\n    else\r\n        set_trans_blender(128, 128, 128, 100);\r\n\r\n    show_mouse(screen);\r\n\r\n    page=create_bitmap(TAILLE_FENETRE_W,TAILLE_FENETRE_H);\r\n\r\n    page_couleur_fond = PAGE_COULEUR_INIT;\r\n\r\n    effacer_page();\r\n\r\n    afficher_page();\r\n}\r\n\r\nvoid fermer_allegro()\r\n{\r\n    if (!page) return;\r\n    destroy_bitmap(page);\r\n    page=NULL;\r\n    allegro_exit();\r\n}\r\n\r\nvoid effacer_page()\r\n{\r\n    if (!page) return;\r\n    clear_to_color(page, page_couleur_fond);\r\n}\r\n\r\nvoid afficher_page()\r\n{\r\n    if (!page) return;\r\n    acquire_screen();\r\n    blit(page, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);\r\n    release_screen();\r\n}\r\n\r\nvoid rafraichir_clavier_souris()\r\n{\r\n    static int mouse_prev, mouse_now;\r\n    static int key_prev[KEY_MAX], key_now[KEY_MAX];\r\n    int k;\r\n\r\n    mouse_prev = mouse_now;\r\n    mouse_now = mouse_b;\r\n    mouse_click = mouse_now & ~mouse_prev;\r\n    mouse_unclick = ~mouse_now & mouse_prev;\r\n\r\n    bouton = '\\0';\r\n    if (mouse_click&1)\r\n        bouton = 'g';\r\n    if (mouse_click&2)\r\n        bouton = 'd';\r\n    if (mouse_click&4)\r\n        bouton = 'm';\r\n\r\n    for (k=0; k<KEY_MAX; k++)\r\n    {\r\n        key_prev[k] = key_now[k];\r\n        key_now[k] = key[k];\r\n        key_press[k] = key_now[k] && !key_prev[k];\r\n        key_unpress[k] = !key_now[k] && key_prev[k];\r\n    }\r\n\r\n    touche = '\\0';\r\n    while (keypressed())\r\n        touche = (char)readkey();\r\n\r\n    get_mouse_mickeys(&mouse_depx, &mouse_depy);\r\n}\r\n\r\nBITMAP *chargerImage(const char* nomFichierImage)\r\n{\r\n    BITMAP *bmp;\r\n    bmp=load_bitmap(nomFichierImage,NULL);\r\n    if (bmp==NULL)\r\n    {\r\n        allegro_message(\"pas pu trouver/charger %s\",nomFichierImage);\r\n        allegro_exit();\r\n        exit(EXIT_FAILURE);\r\n    }\r\n    printf(\"Image charg\\202e : %s\\n\", nomFichierImage);\r\n    return bmp;\r\n}\r\n\r\nvoid changer_nom_fenetre(const char* ch)\r\n{\r\n    set_window_title(ch);\r\n}\r\n\r\nSAMPLE* chargerSon(const char* nomfichier)\r\n{\r\n    SAMPLE* nouv;\r\n    nouv=load_sample(nomfichier);\r\n    if(nouv==NULL)\r\n    {\r\n        allegro_message(\"pas pu trouver/charger %s\",nomfichier);\r\n        allegro_exit();\r\n        exit(EXIT_FAILURE);\r\n    }\r\n    return nouv;\r\n}\r\n\r\n/////////////////date.c////////////////////////\r\nt_date* date_allouer()\r\n{\r\n    t_date* nouv = NULL;\r\n    nouv = (t_date*)malloc(1*sizeof(t_date));\r\n\r\n    nouv->heures = 0;\r\n    nouv->minutes = 0;\r\n    nouv->secondes = 0;\r\n\r\n    return nouv;\r\n}\r\n\r\nvoid date_actualiser(t_date* date)\r\n{\r\n    date->secondes = date->secondes + PAS_DU_TIMER;\r\n    if(date->secondes>= 60)\r\n    {\r\n        date->minutes += 1;\r\n        date->secondes = 0.00;\r\n    }\r\n    if(date->minutes>=60)\r\n    {\r\n        date->heures +=1;\r\n        date->minutes = 0;\r\n    }\r\n}\r\n\r\n/////////////////editeur.c////////////////////////\r\nt_editeur* editeur_allouer(int mode_de_jeu) // sera envoyé par le menu\r\n{\r\n    t_editeur* nouv = NULL;\r\n\r\n    nouv = (t_editeur*)malloc(1*sizeof(t_editeur));\r\n\r\n    nouv->maville = ville_allouer_initialiser(mode_de_jeu);\r\n    nouv->boite_a_outils = boiteaoutils_creer();\r\n    nouv->info=infos_creer();\r\n\r\n    return nouv;\r\n}\r\n\r\nvoid editeur_gerer(t_editeur* ed)\r\n{\r\n    switch(ed->boite_a_outils->bouton_choisi)\r\n    {\r\n        case BOUTON_PAUSE:\r\n        case BOUTON_SAUVEGARDER:\r\n            ed->boite_a_outils->bouton_choisi = -1;\r\n    }\r\n\r\n    if((mouse_x>ed->boite_a_outils->x)&&(mouse_x<ed->boite_a_outils->x+NB_BOUTONS_W*(LARGEUR_CASE+TAILLE_BORDS)+75)&&(mouse_y>ed->boite_a_outils->y)&&(mouse_y<ed->boite_a_outils->y+NB_BOUTONS_H*(LARGEUR_CASE+TAILLE_BORDS)))\r\n    {//On récupère les coordonnées de la souris et on en profite pour changer de référentiel\r\n        int xc = (mouse_x-ed->boite_a_outils->x)/(LARGEUR_CASE+TAILLE_BORDS+75);\r\n        int yc = (mouse_y-ed->boite_a_outils->y)/(LARGEUR_CASE+TAILLE_BORDS);\r\n\r\n        //on donne à la boîte à outil la valeur de l'action sur laquelle à cliqué l'utilisateur afin de définir\r\n        //son comportement par rapport au programme\r\n        if ( bouton=='g' && xc>=0 && xc<NB_BOUTONS_W+75 && yc>=0 && yc<NB_BOUTONS_H )\r\n        {\r\n            ed->boite_a_outils->bouton_choisi=ed->boite_a_outils->matbouton[yc][xc];\r\n        }\r\n    }\r\n    if(mouse_b&2)\r\n    {\r\n        ed->boite_a_outils->bouton_choisi = -1; // Si clic-droit alors on réinitialise le bouton choisi\r\n    }\r\n\r\n\r\n    ville_gerer(ed->maville, ed->boite_a_outils->bouton_choisi);\r\n\r\n}\r\n\r\nint editeur_afficher(t_editeur* ed, int* quitquestion)\r\n{\r\n    int quit ;\r\n    int x,y;\r\n    // on vide le buffer page\r\n    clear_bitmap(page);\r\n\r\n    rectfill(page, 0, 0, TAILLE_FENETRE_W, TAILLE_FENETRE_H, COUL_FOND1);\r\n    rectfill(page, 0, 0, 1024, 20, COUL_FOND);\r\n\r\n    // on construit notre affichage sur le buffer page\r\n    ville_afficher(ed->maville,ed->boite_a_outils->bouton_choisi);\r\n\r\n    rectfill(page, 10/2, 10/2, 20/2, 20/2, makecol(255,0,0));\r\n    rectfill(page, 20/2, 10/2, 30/2, 20/2, makecol(0,255,0));\r\n    rectfill(page, 10/2, 20/2, 20/2, 30/2, makecol(0,0,255));\r\n    rectfill(page, 20/2, 20/2, 30/2, 30/2, makecol(255,228,54));\r\n    rect(page, 0, 0, 1024, 20, COUL_BORD);\r\n    textprintf_ex(page,font,20,7,makecol(0,0,0),-1,\"Windows\");\r\n    if (mouse_x >= 950 && mouse_x <= 1024 && mouse_y <= 20 && mouse_y >=0)\r\n    {\r\n        rectfill(page, 950, 0, 1024, 20, makecol(255,0,0));\r\n        textprintf_ex(page,font,960,7,makecol(0,0,0),-1,\"Quitter\");\r\n\r\n    }\r\n    if (mouse_b&1 && mouse_x >= 950 && mouse_x <= 1024 && mouse_y <= 20 && mouse_y >=0) {\r\n        ed->boite_a_outils->bouton_choisi = -1; // Si clic-droit alors on réinitialise le bouton choisi\r\n        *quitquestion = 1;\r\n    }\r\n\r\n    if (*quitquestion !=0)\r\n    {\r\n        rectfill(page, 325, 265, 600, 365, COUL_FOND);\r\n        rect(page, 324, 264, 601, 366, COUL_BORD);\r\n\r\n        textprintf_ex(page,font,350,290,makecol(0,0,0),-1,\"Voulez vous vraiment quitter ?\");\r\n        if (mouse_x >= 390 && mouse_x <= 430 && mouse_y <= 355 && mouse_y >=320)\r\n        {\r\n            rectfill(page, 390, 320, 430, 335, makecol(255,0,0));\r\n        }\r\n        rect(page, 390, 320, 430, 335, COUL_BORD);\r\n        textprintf_ex(page,font,400,325,makecol(0,0,0),-1,\"OUI\");\r\n\r\n        if (mouse_x >= 490 && mouse_x <= 530 && mouse_y <= 355 && mouse_y >=320)\r\n        {\r\n            rectfill(page, 490, 320, 530, 335, makecol(255,0,0));\r\n        }\r\n        rect(page, 490, 320, 530, 335, COUL_BORD);\r\n        textprintf_ex(page,font,500,325,makecol(0,0,0),-1,\"NON\");\r\n\r\n        if (mouse_b&1 && mouse_x >= 390 && mouse_x <= 430 && mouse_y <= 355 && mouse_y >=320) {\r\n            ed->boite_a_outils->bouton_choisi = -1; // Si clic-droit alors on réinitialise le bouton choisi\r\n            *quitquestion = 0;\r\n            quit = 1;\r\n            //printf(\"%d\", quit);\r\n\r\n        }\r\n        if (mouse_b&1 && mouse_x >= 490 && mouse_x <= 530 && mouse_y <= 355 && mouse_y >=320) {\r\n            ed->boite_a_outils->bouton_choisi = -1; // Si clic-droit alors on réinitialise le bouton choisi\r\n            *quitquestion = 0;\r\n\r\n            //printf(\"%d\", quit);\r\n\r\n        }\r\n    }\r\n    textprintf_ex(page,font,960,7,makecol(0,0,0),-1,\"Quitter\");\r\n    rect(page, 950, 0, 1024, 20, COUL_BORD);\r\n    rect(page, 951, 1, 1023, 19, COUL_BORD);\r\n    rect(page, 952, 2, 1022, 18, COUL_BORD);\r\n\r\n   /* //desert\r\n\r\n    if (mouse_x >= 0 && mouse_x <= 325 && mouse_y >= 585 && mouse_y <=725)\r\n    {\r\n        rectfill(page, 0, 586, 326, 724, COUL_BORD);\r\n    }\r\n\r\n    if (mouse_x >= 0 && mouse_x <= 125 && mouse_y >= 25 && mouse_y <=725)\r\n    {\r\n        rectfill(page, 0, 26, 126, 724, COUL_BORD);\r\n    }\r\n\r\n    if (mouse_x >= 0 && mouse_x <= 205 && mouse_y >= 85 && mouse_y <=725)\r\n    {\r\n        rectfill(page, 0, 86, 206, 724, COUL_BORD);\r\n    }\r\n\r\n    if (mouse_x >= 0 && mouse_x <= 245 && mouse_y >= 285 && mouse_y <=725)\r\n    {\r\n        rectfill(page, 0, 286, 246, 724, COUL_BORD);\r\n    }\r\n\r\n//glace\r\n\r\n    if (mouse_x >= 607 && mouse_x <= 905 && mouse_y >= 25 && mouse_y <=165)\r\n    {\r\n        rectfill(page, 607, 25, 905, 165, COUL_BORD);\r\n    }\r\n\r\n    if (mouse_x >= 806 && mouse_x <= 905 && mouse_y >= 25 && mouse_y <=345)\r\n    {\r\n        rectfill(page, 806, 25, 905, 346, COUL_BORD);\r\n    }\r\n\r\n    if (mouse_x >= 665 && mouse_x <= 905 && mouse_y >= 25 && mouse_y <=205)\r\n    {\r\n        rectfill(page, 665, 25, 905, 205, COUL_BORD);\r\n    }\r\n\r\n    if (mouse_x >= 865 && mouse_x <= 905 && mouse_y >= 25 && mouse_y <=385)\r\n    {\r\n        rectfill(page, 865, 25, 905, 385, COUL_BORD);\r\n    }\r\n\r\n    if (mouse_x >= 765 && mouse_x <= 905 && mouse_y >= 245 && mouse_y <=285)\r\n    {\r\n        rectfill(page, 765, 245, 905, 285, COUL_BORD);\r\n    }*/\r\n\r\n\r\n    boiteaoutils_afficher(ed->boite_a_outils);\r\n\r\n    boiteaoutils_drag(ed->boite_a_outils);\r\n\r\n    info_afficher(ed);\r\n\r\n    info_drag(ed);\r\n    /***** il faudra aussi rajouter les variables du style: argent, nombre d'habitants etc..*****/\r\n    /*textprintf_ex(page,font,112,20,makecol(255,255,255),-1,\"Nombre habitants: %d\",ed->maville->nb_habitants);\r\n    textprintf_ex(page,font,300,20,makecol(255,255,255),-1,\"Argent: %d ECEFlouz\",ed->maville->argent);\r\n    textprintf_ex(page,font,500,20,makecol(255,255,255),-1,\"Temps de jeu: %d:%d:%.0f\",ed->maville->temps_de_jeu->heures,ed->maville->temps_de_jeu->minutes,ed->maville->temps_de_jeu->secondes);\r\n    textprintf_ex(page,font,112,40,makecol(255,255,255),-1,\"Elec dispo:%d/%d\",ed->maville->qte_elec.capacite_disponible,ed->maville->qte_elec.capacite_max);\r\n    textprintf_ex(page,font,500,40,makecol(255,255,255),-1,\"Eau dispo:%d/%d\",ed->maville->qte_eau.capacite_disponible,ed->maville->qte_eau.capacite_max);\r\n    if(ed->maville->pause == PAUSE_ACTIVEE) textprintf_ex(page,font,700,40,makecol(255,255,255),-1,\"PAUSE ACTIVEE\");\r\n*/\r\n    textprintf_ex(page,font,915,640,makecol(255,255,255),-1,\"x:%d , y:%d\",mouse_x,mouse_y);\r\n\r\n    rectfill(page, 910, 650, 1024, 768, COUL_FOND);\r\n    textprintf_ex(page,font,915,660,makecol(255,255,255),-1,\"Temps de jeu:\");\r\n    textprintf_ex(page,font,920,680,makecol(255,255,255),-1,\"%d:%d:%.0f\",ed->maville->temps_de_jeu->heures,ed->maville->temps_de_jeu->minutes,ed->maville->temps_de_jeu->secondes);\r\n    if(ed->maville->pause == PAUSE_ACTIVEE) textprintf_ex(page,font,915,700,makecol(255,255,255),-1,\"PAUSE ACTIVEE\");\r\n    textprintf_ex(page,font,915,720,makecol(255,255,255),-1,\"Cliquez sur S\");\r\n    textprintf_ex(page,font,915,735,makecol(255,255,255),-1,\"pour couper \");\r\n    textprintf_ex(page,font,915,750,makecol(255,255,255),-1,\"le son\");\r\n    // on affiche le buffer page sur l'écran\r\n    //blit(page,screen,0,0,0,0, SCREEN_W, SCREEN_H);\r\n    stretch_blit(page, screen, 0, 0, TAILLE_FENETRE_W, TAILLE_FENETRE_H, 0, 0, SCREEN_W, SCREEN_H);// permet de gérer les ordis\r\n    // incapables d'ouvrir un mode graphique 1024*768\r\n    //rest(150);\r\n    return quit;\r\n}\r\n\r\nvoid editeur_liberer(t_editeur* ed)\r\n{\r\n    //Libération mémoire de la boite à outil\r\n    int l,k;\r\n    for(l=0;l<NB_BOUTONS_H;l++)\r\n    {\r\n        for(k=0;k<NB_BOUTONS_W;k++)\r\n        {\r\n            destroy_bitmap(ed->boite_a_outils->img_bouton_off[l][k]);\r\n            destroy_bitmap(ed->boite_a_outils->img_bouton_on[l][k]);\r\n        }\r\n    }\r\n    free(ed->boite_a_outils);\r\n\r\n    int lig,col;\r\n    int lig1,col1;\r\n    for(lig=0; lig<NB_CASES_LIG; lig++)\r\n    {\r\n        for(col=0; col<NB_CASES_COL; col++)\r\n        {\r\n            if(ed->maville->terrain[lig][col]->type == ROUTE)\r\n            {\r\n                free(ed->maville->terrain[lig][col]->elem);\r\n            }\r\n        }\r\n    }\r\n    for(lig1=0;lig1<NB_CASES_LIG;lig1++)\r\n    {\r\n        for(col1=0;col1<NB_CASES_COL;col1++)\r\n        {\r\n            free(ed->maville->terrain[lig1][col1]);\r\n        }\r\n    }\r\n\r\n    for(lig1=0;lig1<NB_CASES_LIG;lig1++)\r\n    {\r\n        free(ed->maville->terrain[lig1]);\r\n    }\r\n\r\n    free(ed->maville->terrain);\r\n\r\n    int i;\r\n\r\n    for(i=0;i<ed->maville->collec_habitations->taille_actuelle;i++)\r\n    {\r\n        free(ed->maville->collec_habitations->habitation[i]->chateaux_fournisseurs);\r\n        free(ed->maville->collec_habitations->habitation[i]);\r\n    }\r\n    free(ed->maville->collec_habitations->habitation);\r\n    free(ed->maville->collec_habitations);\r\n\r\n    int i0;\r\n\r\n    for(i0=0;i0<ed->maville->collec_casernes->taille_actuelle;i0++)\r\n    {\r\n        free(ed->maville->collec_casernes->caserne[i0]);\r\n    }\r\n    free(ed->maville->collec_casernes->caserne);\r\n    free(ed->maville->collec_casernes);\r\n\r\n    int i1;\r\n\r\n    for(i1=0; i1<ed->maville->collec_chateaux->taille_actuelle; i1++)\r\n    {\r\n        free(ed->maville->collec_chateaux->chateau[i1]);\r\n    }\r\n    free(ed->maville->collec_chateaux->chateau);\r\n    free(ed->maville->collec_chateaux);\r\n\r\n    int i2;\r\n\r\n    for(i2=0; i2<ed->maville->collec_centrales->taille_actuelle; i2++)\r\n    {\r\n        free(ed->maville->collec_centrales->centrale[i2]);\r\n    }\r\n    free(ed->maville->collec_centrales->centrale);\r\n    free(ed->maville->collec_centrales);\r\n\r\n    free(ed->maville->temps_de_jeu);\r\n\r\n    free(ed->maville);\r\n\r\n    free(ed);\r\n}\r\n\r\n/////////////////file.c////////////////////////\r\n// Alloue une file\r\nt_file* file_creer()\r\n{\r\n    return liste_creer();\r\n}\r\n\r\n// Enfile ( = ajoute ) un élément à la file\r\nvoid file_enfiler(t_file* file, void* elem)\r\n{\r\n    liste_ajout_queue(file,elem);\r\n}\r\n\r\n// Défile ( = retire ) un élément à la file\r\nvoid* file_defiler(t_file* file)\r\n{\r\n    return liste_recup_tete(file);\r\n}\r\n\r\n// Retourne 1 si la file est vide, 0 sinon\r\nint file_vide(t_file* file)\r\n{\r\n    return liste_vide(file);\r\n}\r\n\r\n/////////////////file_explorer.c////////////////////////\r\nint obtenir_chemin_sauvegarde(char* chemin)\r\n{\r\n    int res;\r\n\r\n    TCHAR Buffer[MAX_PATH];\r\n    GetCurrentDirectory(MAX_PATH, Buffer);\r\n\r\n    OPENFILENAME ofn;\r\n    TCHAR tmp[TAILLE_BUFFER] ;\r\n    tmp[0]= '\\0' ;\r\n    ZeroMemory ( &ofn , sizeof ( OPENFILENAMEW ) );\r\n    ofn.lStructSize = sizeof ( OPENFILENAMEW );\r\n    ofn.lpstrFile = tmp;\r\n    ofn.nMaxFile = TAILLE_BUFFER;\r\n    ofn.lpstrTitle = _T(\"Le titre\");\r\n    ofn.lpstrFilter = _T(\"Tous (*.*)\\0*.*\\0Textes (*.txt)\\0*.TXT\\0\");\r\n    ofn.lpstrInitialDir = _T(Buffer);\r\n    ofn.Flags = OFN_LONGNAMES | OFN_EXPLORER | OFN_OVERWRITEPROMPT;\r\n    res = GetSaveFileName(&ofn);\r\n    if (res==1)\r\n    {\r\n        // si choix du fichier réussi\r\n        strncpy(chemin,ofn.lpstrFile,TAILLE_CHAINE);\r\n        supprimer_contenu_chaine_apres_point(chemin); // obtient un nom de fichier sans extension déjà incluse\r\n        strncat(chemin,\".txt\",TAILLE_CHAINE); // on rajoute proprement nous même l'extension\r\n    }\r\n    else printf(\"Choix du fichier annule\\n\");\r\n\r\n    return res;\r\n}\r\n\r\nvoid supprimer_contenu_chaine_apres_point(char* chemin)\r\n{\r\n    unsigned int i;\r\n    for(i=0;i<strlen(chemin);i++)\r\n    {\r\n        if (chemin[i] == '.')\r\n        {\r\n            chemin[i] = '\\0';\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nint remplit_chemin_sauvegarde(char* chemin)\r\n{\r\n    int choix_fini;\r\n    choix_fini = obtenir_chemin_sauvegarde(chemin);\r\n    if(choix_fini)\r\n    {\r\n        // on est certain qu'un fichier a bien été choisi (et qu'il ne dispose pas d'une double extension)\r\n        printf(\"Chemin: %s\\n\",chemin);\r\n        return 1;\r\n    }\r\n    else return 0;\r\n}\r\n\r\n/////////////////graphismes.c////////////////////////\r\n\r\nt_graphismes* graphismes_charger()\r\n{\r\n    int i,j;\r\n    int barres_deja_affichees=0;\r\n    char nom_fichier[TAILLE_CHAINE];\r\n    t_graphismes* nouv = NULL;\r\n    nouv = (t_graphismes*)malloc(1*sizeof(t_graphismes));\r\n\r\n\r\n\r\n    ///////////////////////////////////////////\r\n\r\n    nouv->buffer_ville = create_bitmap(GAME_W,GAME_H);\r\n\r\n    clear_bitmap(nouv->buffer_ville);\r\n\r\n    nouv->fond_herbe = chargerImage(\"fichiers/images/jeu/fond_herbe.bmp\");\r\n\r\n    nouv->grille = chargerImage(\"fichiers/images/jeu/grille.bmp\");\r\n\r\n\r\n    for(j=0; j<NB_NIVEAUX; j++)\r\n    {\r\n            sprintf(nom_fichier,\"fichiers/images/jeu/route%d.bmp\",j);\r\n            nouv->route[j]= chargerImage(nom_fichier);\r\n\r\n    }\r\n\r\n    nouv->terrain_vague = chargerImage(\"fichiers/images/jeu/terrain_vague.bmp\");\r\n\r\n    nouv->ruine = chargerImage(\"fichiers/images/jeu/ruine.bmp\");\r\n\r\n    nouv->pompier = chargerImage(\"fichiers/images/jeu/pompier.bmp\");\r\n\r\n    for(i=0; i<NB_IMG_CABANES; i++)\r\n    {\r\n        sprintf(nom_fichier,\"fichiers/images/jeu/cabane%d.bmp\",i);\r\n        nouv->cabane[i] = chargerImage(nom_fichier);\r\n\r\n    }\r\n\r\n    for(i=0; i<NB_IMG_MAISONS; i++)\r\n    {\r\n        sprintf(nom_fichier,\"fichiers/images/jeu/maison%d.bmp\",i);\r\n        nouv->maison[i] = chargerImage(nom_fichier);\r\n\r\n    }\r\n\r\n    for(i=0; i<NB_IMG_IMMEUBLES; i++)\r\n    {\r\n        sprintf(nom_fichier,\"fichiers/images/jeu/immeuble%d.bmp\",i);\r\n        nouv->immeuble[i] = chargerImage(nom_fichier);\r\n\r\n    }\r\n\r\n    for(i=0; i<NB_IMG_GRATTECIELS; i++)\r\n    {\r\n        sprintf(nom_fichier,\"fichiers/images/jeu/gratte_ciel%d.bmp\",i);\r\n        nouv->gratte_ciel[i] = chargerImage(nom_fichier);\r\n\r\n    }\r\n\r\n    nouv->chateau = chargerImage(\"fichiers/images/jeu/chateau.bmp\");\r\n\r\n    nouv->centrale = chargerImage(\"fichiers/images/jeu/centrale.bmp\");\r\n\r\n    nouv->caserne = chargerImage(\"fichiers/images/jeu/caserne.bmp\");\r\n\r\n\r\n\r\n\r\n    return nouv;\r\n}\r\n\r\nvoid graphismes_liberer(t_graphismes* graph)\r\n{\r\n    int i,j;\r\n\r\n    destroy_bitmap(graph->buffer_ville);\r\n\r\n    destroy_bitmap(graph->fond_herbe);\r\n\r\n    destroy_bitmap(graph->grille);\r\n\r\n    for(j=0; j<NB_NIVEAUX; j++)\r\n    {\r\n\r\n            destroy_bitmap(graph->route[j]);\r\n\r\n    }\r\n\r\n    destroy_bitmap(graph->terrain_vague);\r\n    destroy_bitmap(graph->ruine);\r\n    destroy_bitmap(graph->pompier);\r\n\r\n    for(i=0; i<NB_IMG_CABANES; i++)\r\n    {\r\n        destroy_bitmap(graph->cabane[i]);\r\n    }\r\n\r\n    for(i=0; i<NB_IMG_MAISONS; i++)\r\n    {\r\n        destroy_bitmap(graph->maison[i]);\r\n    }\r\n\r\n    for(i=0; i<NB_IMG_IMMEUBLES; i++)\r\n    {\r\n        destroy_bitmap(graph->immeuble[i]);\r\n    }\r\n\r\n    for(i=0; i<NB_IMG_GRATTECIELS; i++)\r\n    {\r\n        destroy_bitmap(graph->gratte_ciel[i]);\r\n    }\r\n\r\n    destroy_bitmap(graph->chateau);\r\n    destroy_bitmap(graph->centrale);\r\n    destroy_bitmap(graph->caserne);\r\n\r\n    free(graph);\r\n}\r\n\r\n/////////////////habitation.c////////////////////////\r\nt_habitation* habitation_creer()\r\n{\r\n    int i;\r\n    t_habitation* nouv;\r\n\r\n    nouv=malloc(sizeof(t_habitation));\r\n    nouv->chateaux_fournisseurs=malloc(FOURNISSEUR_MAX*sizeof(t_fournisseur));\r\n    for(i=0; i<FOURNISSEUR_MAX; i++)\r\n    {\r\n        nouv->chateaux_fournisseurs[i].id_fournisseur.caseX = -1;\r\n        nouv->chateaux_fournisseurs[i].id_fournisseur.caseY = -1;\r\n        nouv->chateaux_fournisseurs[i].qte_eau_distribuee = 0;\r\n    }\r\n\r\n    nouv->chrono = 0.00;\r\n    nouv->feu= PAS_EN_FEU;\r\n    nouv->stade= STADE_TERRAIN_VAGUE;\r\n    nouv->case_de_referenceX = 0;\r\n    nouv->case_de_referenceY = 0;\r\n    nouv->electricite = 0;\r\n    nouv->eau = 0;\r\n    nouv->indice = 0;\r\n    nouv->id_centrale_fournisseuse.caseX = -1;\r\n    nouv->id_centrale_fournisseuse.caseY = -1;\r\n    return nouv;\r\n}\r\n\r\nint habitation_place_libre(int col,int lig,t_case*** kase)\r\n{\r\n    int i,j;\r\n    int libre=1;\r\n    if(!habitation_depassement_matrice(col,lig))\r\n    {\r\n        for(i=lig; i<lig+HABITATION_H; i++)\r\n        {\r\n            for(j=col; j<col+HABITATION_W; j++)\r\n            {\r\n                ///PEUT MIEUX FAIRE (RETURN LIBRE IF LIBRE ==0)\r\n                if(kase[i][j]->type!=VIDE)\r\n                {\r\n                    libre=0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else libre=0;\r\n    return libre;\r\n}\r\n\r\nint habitation_depassement_matrice(int colonne,int ligne)\r\n{\r\n    int depasse=1;\r\n    if((colonne>=0)&&(colonne<=NB_CASES_COL-HABITATION_W)&&(ligne>=0)&&(ligne<=NB_CASES_LIG-HABITATION_H))\r\n    {\r\n        depasse=0;\r\n    }\r\n    return depasse;\r\n}\r\n\r\nvoid habitation_placer(t_habitation* h,int col,int lig,t_case*** kase)\r\n{\r\n    int i,j;\r\n    h->case_de_referenceX=col;\r\n    h->case_de_referenceY=lig;\r\n    for(i=lig; i<lig+HABITATION_H; i++)\r\n    {\r\n        for(j=col; j<col+HABITATION_W; j++)\r\n        {\r\n            kase[i][j]->type=HABITATION;\r\n            kase[i][j]->elem=h;\r\n        }\r\n    }\r\n}\r\n\r\nint habitation_nbhabitants(t_habitation* habitation)\r\n{\r\n    int habitants = NB_HABITANTS_RUINE;\r\n\r\n    switch(habitation->stade)\r\n    {\r\n        case STADE_RUINE :\r\n            habitants=NB_HABITANTS_RUINE; // ruine\r\n            break;\r\n\r\n        case STADE_TERRAIN_VAGUE :\r\n            habitants=NB_HABITANTS_TERRAIN_VAGUE; // terrain vague\r\n            break;\r\n\r\n        case STADE_CABANE :\r\n            habitants=NB_HABITANTS_CABANE; // cabane\r\n            break;\r\n\r\n        case STADE_MAISON :\r\n            habitants=NB_HABITANTS_MAISON; // maison\r\n            break;\r\n\r\n        case STADE_IMMEUBLE :\r\n            habitants=NB_HABITANTS_IMMEUBLE; // immeuble\r\n            break;\r\n\r\n        case STADE_GRATTECIEL:\r\n            habitants=NB_HABITANTS_GRATTECIEL; // gratte-ciel\r\n    }\r\n    return habitants;\r\n}\r\n\r\nint habitation_comparer(const void* a, const void* b)\r\n{\r\n    const t_habitation* const* h1 = a; // en théorie ici il manque un degré de \"const\", comment savoir que c'était un pointeur constant sur pointeur (non constant) d'habitation constante qu'on voulait??\r\n    const t_habitation* const* h2 = b;\r\n    if((*h1)->stade < (*h2)->stade)\r\n    {\r\n        return 1;\r\n    }\r\n    else if((*h1)->stade > (*h2)->stade)\r\n    {\r\n        return -1;\r\n    }\r\n    else\r\n        return 0;\r\n}\r\n\r\nvoid habitation_evoluer(t_habitation* habitation,int mode,int* argent,int nb_chateaux,int nb_centrales,int** longueurs_chateaux,int** longueurs_centrales,int* capacite_chateau,int* capacite_centrale)\r\n{\r\n    if(habitation->feu)\r\n    {\r\n        if(habitation->feu==DUREE_INCENDIE)\r\n        {\r\n            habitation->feu=PAS_EN_FEU;\r\n            if(!habitation->protegee)\r\n            {\r\n                habitation->stade=STADE_RUINE;\r\n            }\r\n        }\r\n        if( habitation->chrono >= DUREE_CYCLE)\r\n        {\r\n            habitation->chrono = 0;\r\n        }\r\n    }\r\n    else if( habitation->chrono >= DUREE_CYCLE) // si 15 secondes se sont écoulées\r\n    {\r\n        habitation->chrono = 0; // on remet à 0 la durée\r\n        *argent = *argent + habitation_recolter_impots(habitation);\r\n\r\n        switch(mode)\r\n        {\r\n            case MODE_CAPITALISTE : habitation_evolution_capitaliste(habitation,nb_chateaux,nb_centrales,longueurs_chateaux,longueurs_centrales);\r\n\r\n                break;\r\n\r\n            case MODE_COMMUNISTE : habitation_evolution_communiste(habitation,nb_chateaux,nb_centrales,longueurs_chateaux,longueurs_centrales,capacite_chateau,capacite_centrale);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nvoid habitation_progression(t_habitation* habitation)\r\n{\r\n    if((habitation->stade<STADE_GRATTECIEL)&&(habitation->stade!=STADE_RUINE))\r\n    {\r\n        habitation->stade+=1;\r\n    }\r\n}\r\n\r\nvoid habitation_regression(t_habitation* habitation)\r\n{\r\n    if(habitation->stade==STADE_CABANE)\r\n    {\r\n        habitation->stade=STADE_RUINE;\r\n    }\r\n    if(habitation->stade>STADE_TERRAIN_VAGUE)\r\n    {\r\n        habitation->stade-=1;\r\n    }\r\n}\r\n\r\nvoid habitation_evolution_communiste(t_habitation* habitation,int nb_chateaux,int nb_centrales,int** longueurs_chateaux,int** longueurs_centrales,int* capacite_chateaux,int* capacite_centrale)\r\n{\r\n    int i,eau_dispo=0,elec_dispo=0,quantitee_future;\r\n    for(i=0;i<nb_chateaux;i++)\r\n    {///ON REGARDE L'EAU DISPO SUR LE RESEAU\r\n        if(longueurs_chateaux[i][habitation->indice])\r\n        {\r\n            eau_dispo+=capacite_chateaux[i];\r\n        }\r\n    }\r\n    for(i=0;i<nb_centrales;i++)\r\n    {///ON REGARDE L'ELEC DISPO SUR LE RESEAU\r\n        if(longueurs_centrales[i][habitation->indice])\r\n        {\r\n            elec_dispo+=capacite_centrale[i];\r\n        }\r\n    }\r\n    if((habitation->eau==0)||(habitation->electricite==0)) ///SI L'HABITATION N'EST PAS ALIM, ELLE REGRESSE\r\n    {\r\n        habitation_regression(habitation);\r\n    }\r\n    else\r\n    {///ON REGARDE LA QUANTITEE DONT ELLE AURA BESOIN SI ELLE EVOLUE\r\n        quantitee_future=habitation->stade+1;\r\n        switch(quantitee_future)\r\n        {\r\n            case STADE_CABANE : quantitee_future = NB_HABITANTS_CABANE;\r\n                break;\r\n\r\n            case STADE_MAISON : quantitee_future = NB_HABITANTS_MAISON;\r\n                break;\r\n\r\n            case STADE_IMMEUBLE : quantitee_future = NB_HABITANTS_IMMEUBLE;\r\n                break;\r\n\r\n            case STADE_GRATTECIEL : quantitee_future = NB_HABITANTS_GRATTECIEL;\r\n                break;\r\n        }\r\n\r\n        //desert\r\n\r\n        if (habitation->case_de_referenceX >= 0 && habitation->case_de_referenceX <= 325 && habitation->case_de_referenceY >= 585 && habitation->case_de_referenceX <=725)\r\n        {\r\n            quantitee_future+=habitation_nbhabitants(habitation);\r\n        }\r\n\r\n        if (habitation->case_de_referenceX >= 0 && habitation->case_de_referenceX <= 125 && habitation->case_de_referenceY >= 25 && habitation->case_de_referenceY <=725)\r\n        {\r\n            quantitee_future+=habitation_nbhabitants(habitation);\r\n        }\r\n\r\n        if (habitation->case_de_referenceX >= 0 && habitation->case_de_referenceX <= 205 && habitation->case_de_referenceY >= 85 && habitation->case_de_referenceY <=725)\r\n        {\r\n            quantitee_future+=habitation_nbhabitants(habitation);\r\n        }\r\n\r\n        if (habitation->case_de_referenceX >= 0 && habitation->case_de_referenceX <= 245 && habitation->case_de_referenceY >= 285 && habitation->case_de_referenceY <=725)\r\n        {\r\n            quantitee_future+=habitation_nbhabitants(habitation);\r\n        }\r\n\r\n//glace\r\n\r\n        if (habitation->case_de_referenceX >= 607 && habitation->case_de_referenceX <= 905 && habitation->case_de_referenceY >= 25 && habitation->case_de_referenceY <=165)\r\n        {\r\n            quantitee_future+=habitation_nbhabitants(habitation);\r\n        }\r\n\r\n        if (habitation->case_de_referenceX >= 806 && habitation->case_de_referenceX <= 905 && habitation->case_de_referenceY >= 25 && habitation->case_de_referenceY <=345)\r\n        {\r\n            quantitee_future+=habitation_nbhabitants(habitation);\r\n        }\r\n\r\n        if (habitation->case_de_referenceX >= 665 && habitation->case_de_referenceX <= 905 && habitation->case_de_referenceY >= 25 && habitation->case_de_referenceY <=205)\r\n        {\r\n            quantitee_future+=habitation_nbhabitants(habitation);\r\n        }\r\n\r\n        if (habitation->case_de_referenceX >= 865 && habitation->case_de_referenceX <= 905 && habitation->case_de_referenceY >= 25 && habitation->case_de_referenceY <=385)\r\n        {\r\n            quantitee_future+=habitation_nbhabitants(habitation);\r\n        }\r\n\r\n        if (habitation->case_de_referenceX >= 765 && habitation->case_de_referenceX <= 905 && habitation->case_de_referenceY >= 245 && habitation->case_de_referenceY <=285)\r\n        {\r\n            quantitee_future+=habitation_nbhabitants(habitation);\r\n        }\r\n\r\n        else\r\n        {\r\n            quantitee_future-=habitation_nbhabitants(habitation);\r\n        }\r\n\r\n\r\n\r\n        if((eau_dispo>=quantitee_future)&&(elec_dispo>=quantitee_future)) ///SI LA QUANTITEE DISPONIBLE EST SUPERIEURE A LA\r\n        {                                                               ///QUANTITEE FUTURE, ON AUGMENTE LE BATIMENT\r\n            habitation_progression(habitation);\r\n        }\r\n    }\r\n}\r\n\r\nvoid habitation_evolution_capitaliste(t_habitation* habitation,int nb_chateaux,int nb_centrales,int** longueurs_chateaux,int** longueurs_centrales)\r\n{\r\n    int connect_elec=0,connect_eau=0,i;\r\n    for(i=0;i<nb_chateaux;i++)\r\n    {\r\n        if(longueurs_chateaux[i][habitation->indice])\r\n        {\r\n            connect_eau=1;\r\n        }\r\n    }\r\n    for(i=0;i<nb_centrales;i++)\r\n    {\r\n        if(longueurs_centrales[i][habitation->indice])\r\n        {\r\n            connect_elec=1;\r\n        }\r\n    }\r\n    if((habitation->stade==STADE_TERRAIN_VAGUE)&&(connect_eau)&&(connect_elec))\r\n    {\r\n        habitation_progression(habitation);\r\n    }\r\n    else\r\n    {\r\n        if((habitation->eau==0)||(habitation->electricite==0))\r\n        {\r\n            if(habitation->stade>STADE_TERRAIN_VAGUE)\r\n                habitation_regression(habitation);\r\n        }\r\n        else\r\n        {\r\n            if(habitation->stade<STADE_GRATTECIEL)\r\n                habitation_progression(habitation);\r\n        }\r\n    }\r\n}\r\n\r\nint habitation_recolter_impots(t_habitation* hab)\r\n{\r\n    return IMPOTS_PAR_HABITANT*habitation_nbhabitants(hab);\r\n}\r\n\r\n/////////////////liste_generique_simple_chainage.c////////////////////////\r\n/// Variables globales pour tracer le bilan des allocations/libérations des maillons\r\n\r\n// Total des maillons alloués\r\nint nb_maillons_alloues = 0;\r\n\r\n// Total des maillons libérés\r\nint nb_maillons_liberes = 0;\r\n\r\n/// Implémentation des sous-programmes du module\r\n\r\n// Constructeur\r\nt_liste* liste_creer()\r\n{\r\n    t_liste* nouv;\r\n    nouv = (t_liste*) malloc(1*sizeof(t_liste));\r\n\r\n    nouv->longueur = 0;\r\n    nouv->p_tete = NULL;\r\n    nouv->p_queue = NULL;\r\n    nouv->p_courant = NULL;\r\n\r\n    return nouv;\r\n}\r\n\r\n// Ajout d'élément en queue\r\nvoid liste_ajout_queue(t_liste* lst, void* elem)\r\n{\r\n    t_maillon* nouv;\r\n    nouv = (t_maillon*) malloc(1*sizeof(t_maillon));\r\n    nouv->elem = elem; // on accroche la donnée reçue en paramètre\r\n    nouv->p_suiv = NULL;\r\n\r\n    nb_maillons_alloues++; // on augmente le compteur de bilan mémoire\r\n\r\n    if(liste_vide(lst)) // si la liste était vide\r\n    {\r\n        lst->p_queue = nouv; // on accroche le nouveau maillon sur la queue\r\n        lst->p_tete = nouv; // on met à jour la tete aussi\r\n    }\r\n    else\r\n    {\r\n        lst->p_queue->p_suiv = nouv; // on accroche le nouveau maillon sur la queue actuelle\r\n        lst->p_queue = nouv; // on met à jour la queue\r\n    }\r\n    lst->longueur = lst->longueur + 1;\r\n}\r\n\r\n// Retourne 1 (Vrai) si la liste est vide\r\nint liste_vide(t_liste* lst)\r\n{\r\n    return (lst->longueur ==0) ? 1 : 0;\r\n}\r\n\r\nvoid* liste_recup_tete(t_liste* lst)\r\n{\r\n    t_maillon* tmp = NULL;\r\n    void* elem_tete = NULL;\r\n\r\n    if(!liste_vide(lst))\r\n    {\r\n        tmp = lst->p_tete->p_suiv;\r\n        elem_tete = lst->p_tete->elem;\r\n        free(lst->p_tete); // on détruit le maillon, mais pas les données.\r\n        lst->p_tete = tmp; // on fait pointer la tête sur le successeur du maillon détruit\r\n        lst->longueur = lst->longueur -1; // on diminue la longueur de la liste\r\n        nb_maillons_liberes++;  // on augmente le compteur de bilan mémoire\r\n    }\r\n    else\r\n    {\r\n        printf(\"erreur, impossible supprimer tete, la liste est vide\\n\");\r\n    }\r\n\r\n    return elem_tete;\r\n}\r\n\r\n/////////////////menu.c////////////////////////\r\nvoid menu(BITMAP* menu1, t_graphMenu* graph)\r\n{\r\n    int son=1;\r\n    graph->music = chargerSon(\"fichiers/sound.wav\");//initialisation du son\r\n    play_sample(graph->music, 255, 127, 1000, 1); //jouer la musique\r\n    while(!key[KEY_ESC])\r\n    {\r\n        if(key_press[KEY_S] && son==0)//remet la musique en marche\r\n        {\r\n            son= 1;\r\n            play_sample(graph->music, 255, 127, 1000, 1); //on joue la musique\r\n        }\r\n        else if(key_press[KEY_S] && son==1)//arrete la musique\r\n        {\r\n            son= 0;\r\n            stop_sample(graph->music);\r\n        }\r\n        blit(menu1, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);//on affiche le menu de choix des langues\r\n        if((mouse_b&1) && (mouse_x >= 120) && (mouse_x <= 350) && (mouse_y >= 300) && (mouse_y <= 550))//si l'utilisateur a cliqué sur le drapeau du RU\r\n        {\r\n            //chargement des bitmap anglaises\r\n        }\r\n        else if((mouse_b&1) && (mouse_x >= 480) && (mouse_x <= 850) && (mouse_y >= 380) && (mouse_y <= 820))//le clic se situe sur le drapeau français\r\n        {\r\n            BITMAP* menuFR=chargerImage(\"fichiers/images/menu1/menuFR/menu2FR.bmp\");//chargement des bitmap françaises\r\n            menuBisFR(menu1, menuFR,  graph);//on lance le jeu en français\r\n            destroy_bitmap(menuFR);\r\n        }\r\n    }\r\n}\r\n\r\nint menuModeFR(BITMAP* menufr, BITMAP* menuModefr, t_graphMenu* graph)//menu choix du mode\r\n{\r\n    int mode, quitter;\r\n    mode=-1;\r\n    quitter=-1;\r\n    blit(menuModefr, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);//on affiche le menu de choix du mode communiste/capitaliste\r\n    while(quitter == -1)\r\n    {\r\n        if ((mouse_b & 1) && (mouse_x >= 0) && (mouse_x <= 470) && (mouse_y >= 300) && (mouse_y <= 500))//si l'utilisateur a cliqué sur les règles\r\n        {\r\n            printf(\"mode communiste\\n\");\r\n            mode=MODE_COMMUNISTE;//jeu en mode communiste\r\n            quitter=1;\r\n        }\r\n        else if ((mouse_b & 1) && (mouse_x >= 550) && (mouse_x <= 1024) && (mouse_y >= 300) && (mouse_y <= 500))//si l'utilisateur a cliqué sur les règles\r\n        {\r\n            printf(\"mode capitaliste\\n\");\r\n            mode=MODE_CAPITALISTE;//jeu en mode capitaliste\r\n            quitter=1;\r\n        }\r\n        rest(20);\r\n    }\r\n    return mode;//on retourne la valeur du mode\r\n}\r\n\r\nvoid menuBisFR(BITMAP* menu1, BITMAP* menuFR, t_graphMenu* graph)\r\n{\r\n    int choix;\r\n    BITMAP* menufr=chargerImage(\"fichiers/images/menu1/menuFR/menu2FR.bmp\");//chargement des bitmap anglaises\r\n    BITMAP* menuModefr=chargerImage(\"fichiers/images/menu1/menuFR/menuModeFR.bmp\");\r\n    BITMAP* menuReglesfr=chargerImage(\"fichiers/images/menu1/menuFR/menuReglesFR.bmp\");\r\n    blit(menufr, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);//on affiche le menu en français\r\n    while(!key[KEY_ESC])\r\n    {\r\n        if((mouse_b&1) && (mouse_x >= 10) && (mouse_x <= 60) && (mouse_y >= 10) && (mouse_y <= 60))//si l'utilisateur a cliqué sur la croix rouge\r\n        {\r\n            printf(\"quitter\\n\");\r\n            destroy_bitmap(menufr);\r\n            destroy_bitmap(menuModefr);\r\n            destroy_bitmap(menuReglesfr);//on détruit les bitmap\r\n            allegro_exit();\r\n            exit(EXIT_FAILURE);//on quitte le jeu\r\n        }\r\n        else if((mouse_b&1) && (mouse_x >= 100) && (mouse_x <= 950) && (mouse_y >= 165) && (mouse_y <= 265))//si l'utilisateur a cliqué sur \"nouvelle partie\"\r\n        {\r\n            printf(\"jouer\\n\");\r\n            choix=menuModeFR(menufr, menuModefr, graph);//le joueur choisi le mode de la partie\r\n            destroy_bitmap(menufr);\r\n            destroy_bitmap(menuModefr);\r\n            destroy_bitmap(menuReglesfr);//on détruit les bitmap\r\n            menu_boucle_jeu(choix,NULL,*graph);//on lance la boucle de jeu\r\n        }\r\n        else if((mouse_b&1) && (mouse_x >= 100) && (mouse_x <= 950) && (mouse_y >= 350) && (mouse_y <= 450))//si l'utilisateur a cliqué sur \"charger partie\"\r\n        {\r\n            printf(\"quitter\\n\");\r\n            destroy_bitmap(menufr);\r\n            destroy_bitmap(menuModefr);\r\n            destroy_bitmap(menuReglesfr);//on détruit les bitmap\r\n            allegro_exit();\r\n            exit(EXIT_FAILURE);//on quitte le jeu\r\n        }\r\n        else if((mouse_b&1) && (mouse_x >= 100) && (mouse_x <= 950) && (mouse_y >= 560) && (mouse_y <= 660))//si l'utilisateur a cliqué sur \"règles du jeu\"\r\n        {\r\n            printf(\"regles\\n\");\r\n            menuReglesFR(menufr, menuReglesfr, menu1, graph);//on affiche les règles du jeu\r\n        }\r\n    }\r\n}\r\n\r\nvoid menuReglesFR(BITMAP* menufr, BITMAP* menuReglesfr, BITMAP* menu1, t_graphMenu* graph)//affichage des règles du jeu\r\n{\r\n    blit(menuReglesfr, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);//on affiche le menu en français\r\n    while(!key[KEY_ESC])\r\n    {\r\n        if((mouse_b&1) && (mouse_x >= 0) && (mouse_x <= 100) && (mouse_y >= 650) && (mouse_y <= 768))//si l'utilisateur a cliqué sur la flèche de retour\r\n        {\r\n            menuBisFR(menu1, menufr, graph);//on retourne au menu\r\n        }\r\n    }\r\n}\r\n\r\nvoid menu_boucle_jeu(int mode,const char* nom_fichier,t_graphMenu graph)\r\n{\r\n    int quitte,son;\r\n    quitte=0;\r\n    son=0;\r\n    t_editeur* ed = NULL;\r\n    switch(mode)\r\n    {\r\n        case MODE_CAPITALISTE:\r\n            ed = editeur_allouer(MODE_CAPITALISTE);\r\n            break;\r\n        case MODE_COMMUNISTE:\r\n            ed = editeur_allouer(MODE_COMMUNISTE);\r\n            break;\r\n        case CHARGER:\r\n            ed = editeur_allouer(MODE_CAPITALISTE); // osef on va le changer en chargeant la ville\r\n            ville_charger(nom_fichier,ed->maville);\r\n            break;\r\n    }\r\n    while((!key[KEY_ESC])&&(quitte != 1))\r\n    {\r\n        if(key_press[KEY_S] && son==0)//joue la musique\r\n        {\r\n            son=1;//on met le son à 1\r\n            play_sample(graph.music, 255, 127, 1000, 1);//on joue la musique\r\n        }\r\n        else if(key_press[KEY_S] && son==1)//arrête la musique\r\n        {\r\n            son=0;//on met le son à 0\r\n            stop_sample(graph.music);//on arrete la musique\r\n        }\r\n        rafraichir_clavier_souris();\r\n        editeur_gerer(ed);\r\n        quitte=editeur_afficher(ed);\r\n        rest(0.1);\r\n    }\r\n    editeur_liberer(ed);\r\n}\r\n/////////////////route.c////////////////////////\r\nt_route* route_creer()\r\n{\r\n    t_route* nouv;\r\n    nouv=malloc(sizeof(t_route));\r\n\r\n    nouv->case_de_referenceX = 0;\r\n    nouv->case_de_referenceY = 0;\r\n    nouv->type = TYPE_ROUTE_HORIZONTALE;\r\n\r\n    return nouv;\r\n}\r\n\r\n/*void route_actualiser(t_route* route,t_case*** kase)\r\n{\r\n    int colonne,ligne;\r\n    colonne=route->case_de_referenceX;\r\n    ligne=route->case_de_referenceY;\r\n    route->type=TYPE_ROUTE_HORIZONTALE;\r\n    if(ligne>0)\r\n    {\r\n        if(kase[ligne-1][colonne]->type==ROUTE) route->type=TYPE_ROUTE_VERTICALE;\r\n    }\r\n    if(ligne<NB_CASES_LIG-1)\r\n    {\r\n        if(kase[ligne+1][colonne]->type==ROUTE) route->type=TYPE_ROUTE_VERTICALE;\r\n    }\r\n    if(colonne>0)\r\n    {\r\n        if(kase[ligne][colonne-1]->type==ROUTE) route->type=TYPE_ROUTE_HORIZONTALE;\r\n    }\r\n    if(colonne<NB_CASES_COL-1)\r\n    {\r\n        if(kase[ligne][colonne+1]->type==ROUTE) route->type=TYPE_ROUTE_HORIZONTALE;\r\n    }\r\n    if((colonne>0)&&(ligne>0))\r\n    {\r\n        if((kase[ligne][colonne-1]->type==ROUTE)&&(kase[ligne-1][colonne]->type==ROUTE)) route->type=TYPE_ROUTE_HAUT_GAUCHE;\r\n    }\r\n    if((colonne<NB_CASES_COL-1)&&(ligne<NB_CASES_LIG-1))\r\n    {\r\n        if((kase[ligne][colonne+1]->type==ROUTE)&&(kase[ligne+1][colonne]->type==ROUTE)) route->type=TYPE_ROUTE_BAS_DROITE;\r\n    }\r\n    if((colonne<NB_CASES_COL-1)&&(ligne>0))\r\n    {\r\n        if((kase[ligne][colonne+1]->type==ROUTE)&&(kase[ligne-1][colonne]->type==ROUTE)) route->type=TYPE_ROUTE_HAUT_DROITE;\r\n    }\r\n    if((colonne>0)&&(ligne<NB_CASES_LIG-1))\r\n    {\r\n        if((kase[ligne][colonne-1]->type==ROUTE)&&(kase[ligne+1][colonne]->type==ROUTE)) route->type=TYPE_ROUTE_BAS_GAUCHE;\r\n    }\r\n    if((colonne<NB_CASES_COL-1)&&(ligne<NB_CASES_LIG-1)&&(colonne>0))\r\n    {\r\n        if((kase[ligne][colonne+1]->type==ROUTE)&&(kase[ligne+1][colonne]->type==ROUTE)&&(kase[ligne][colonne-1]->type==ROUTE)) route->type=TYPE_ROUTE_GAUCHE_DROITE_BAS;\r\n    }\r\n    if((colonne<NB_CASES_COL-1)&&(ligne>0)&&(colonne>0))\r\n    {\r\n        if((kase[ligne][colonne+1]->type==ROUTE)&&(kase[ligne-1][colonne]->type==ROUTE)&&(kase[ligne][colonne-1]->type==ROUTE)) route->type=TYPE_ROUTE_GAUCHE_DROITE_HAUT;\r\n    }\r\n    if((colonne<NB_CASES_COL-1)&&(ligne<NB_CASES_LIG-1)&&(ligne>0))\r\n    {\r\n        if((kase[ligne][colonne+1]->type==ROUTE)&&(kase[ligne+1][colonne]->type==ROUTE)&&(kase[ligne-1][colonne]->type==ROUTE)) route->type=TYPE_ROUTE_DROITE_BAS_HAUT;\r\n    }\r\n    if((colonne>0)&&(ligne<NB_CASES_LIG-1)&&(ligne>0))\r\n    {\r\n        if((kase[ligne][colonne-1]->type==ROUTE)&&(kase[ligne+1][colonne]->type==ROUTE)&&(kase[ligne-1][colonne]->type==ROUTE)) route->type=TYPE_ROUTE_GAUCHE_BAS_HAUT;\r\n    }\r\n    if((colonne<NB_CASES_COL-1)&&(ligne<NB_CASES_LIG-1)&&(ligne>0)&&(colonne>0))\r\n    {\r\n        if((kase[ligne][colonne+1]->type==ROUTE)&&(kase[ligne+1][colonne]->type==ROUTE)&&(kase[ligne-1][colonne]->type==ROUTE)&&(kase[ligne][colonne-1]->type==ROUTE)) route->type=TYPE_ROUTE_INTERSECTION;\r\n    }\r\n}*/\r\n\r\n/*void route_actualiser_voisins(t_route* route,t_case*** kase)\r\n{\r\n    int ligne,colonne;\r\n\r\n    ligne=route->case_de_referenceY;\r\n    colonne=route->case_de_referenceX;\r\n\r\n    if(colonne>0)\r\n    {\r\n        if(kase[ligne][colonne-1]->type==ROUTE)\r\n        {\r\n            route_actualiser(kase[ligne][colonne-1]->elem,kase);\r\n        }\r\n    }\r\n    if(colonne<NB_CASES_COL-1)\r\n    {\r\n        if(kase[ligne][colonne+1]->type==ROUTE)\r\n        {\r\n            route_actualiser(kase[ligne][colonne+1]->elem,kase);\r\n        }\r\n    }\r\n    if(ligne<NB_CASES_LIG-1)\r\n    {\r\n        if(kase[ligne+1][colonne]->type==ROUTE)\r\n        {\r\n            route_actualiser(kase[ligne+1][colonne]->elem,kase);\r\n        }\r\n    }\r\n    if(ligne>0)\r\n    {\r\n        if(kase[ligne-1][colonne]->type==ROUTE)\r\n        {\r\n            route_actualiser(kase[ligne-1][colonne]->elem,kase);\r\n        }\r\n    }\r\n}*/\r\n\r\nint route_place_libre(int colonne,int ligne,t_case*** kase)\r\n{\r\n    int libre=1;\r\n    if(!route_depassement_matrice(colonne,ligne))\r\n    {\r\n        libre=case_libre(kase[ligne][colonne]);\r\n    }\r\n    else libre=0;\r\n    return libre;\r\n}\r\n\r\nint route_depassement_matrice(int colonne,int ligne)\r\n{\r\n    int depasse=1;\r\n    if((colonne>=0)&&(colonne<NB_CASES_COL)&&(ligne>=0)&&(ligne<NB_CASES_LIG))\r\n    {\r\n        depasse=0;\r\n    }\r\n    return depasse;\r\n}\r\n\r\nvoid route_placer(t_route* route,int colonne,int ligne,t_case*** kase)\r\n{\r\n    route->case_de_referenceX=colonne;\r\n    route->case_de_referenceY=ligne;\r\n\r\n    //route_actualiser(route,kase);\r\n\r\n    kase[ligne][colonne]->type=ROUTE;\r\n    kase[ligne][colonne]->elem=route;\r\n    //route_actualiser_voisins(route,kase);\r\n}\r\n\r\nvoid route_afficher(t_route* route,int niveau)\r\n{\r\n    draw_sprite(graphs->buffer_ville,graphs->route[niveau],1+TAILLE_CASE*route->case_de_referenceX,1+TAILLE_CASE*route->case_de_referenceY);\r\n}\r\n\r\n/////////////////terrain.c////////////////////////\r\nt_case*** terrain_allouer()\r\n{\r\n    int lig,col;\r\n    t_case*** nouv;\r\n\r\n    nouv = (t_case***)malloc(NB_CASES_LIG*sizeof(t_case**));\r\n    for(lig=0;lig<NB_CASES_LIG;lig++)\r\n    {\r\n        nouv[lig] = (t_case**)malloc(NB_CASES_COL*sizeof(t_case*));\r\n    }\r\n\r\n    for(lig=0;lig<NB_CASES_LIG;lig++)\r\n    {\r\n        for(col=0;col<NB_CASES_COL;col++)\r\n        {\r\n            nouv[lig][col] = case_allouer();\r\n        }\r\n    }\r\n\r\n    return nouv;\r\n}\r\n\r\n/// A APPELER APRES AVOIR LIBERE LES COLLECTIONS DE STRUCTURES (habitations, casernes, chateaux, centrales etc...)\r\n/// SINON, fuite mémoire\r\n\r\n/////////////////ville.c////////////////////////\r\nt_ville* ville_allouer_initialiser(int mode_de_jeu)\r\n{\r\n    t_ville* nouv = NULL;\r\n    nouv = (t_ville*)malloc(1*sizeof(t_ville));\r\n\r\n    nouv->argent = ARGENT_INITIAL;\r\n    nouv->nb_habitants = 0;\r\n    nouv->qte_eau.capacite_disponible = 0;\r\n    nouv->qte_eau.capacite_max = 0;\r\n    nouv->qte_elec.capacite_disponible = 0;\r\n    nouv->qte_elec.capacite_max = 0;\r\n    nouv->timer = clock();\r\n    nouv->pause = PAUSE_DESACTIVEE;\r\n    nouv->niveau_visualisation = NIVEAU_SOL;\r\n    nouv->mode = mode_de_jeu;\r\n    nouv->temps_de_jeu = date_allouer();\r\n\r\n    nouv->terrain = terrain_allouer();\r\n\r\n    nouv->collec_habitations = collection_habitation_creer();\r\n    nouv->collec_centrales = collection_centrale_creer();\r\n    nouv->collec_casernes = collection_casernes_creer();\r\n    nouv->collec_chateaux = collection_chateau_creer();\r\n\r\n    nouv->data_bfs.case_de_referenceX =0;\r\n    nouv->data_bfs.case_de_referenceY =0;\r\n    nouv->data_bfs.ordre =0;\r\n\r\n    return nouv;\r\n}\r\n\r\nvoid ville_sauvegarder(const char* nom_fichier,t_ville* v)\r\n{\r\n    int i,j;\r\n    FILE* fp;\r\n\r\n    fp=fopen(nom_fichier,\"w\");\r\n    if(fp==NULL)\r\n    {\r\n        printf(\"ERREUR FICHIER DE SAUVEGARDE\");\r\n        exit(1);\r\n    }\r\n    ///ON ECRIT LE MODE DE JEU\r\n    fprintf(fp,\"%d %d\\n\",v->mode,v->argent);\r\n    fprintf(fp,\"%d %d %lf\\n\",v->temps_de_jeu->heures,v->temps_de_jeu->minutes,v->temps_de_jeu->secondes);\r\n    ///ON ECRIT LA MATRICE DU TERRAIN (pour pouvoir charger les routes)\r\n    for(i=0; i<NB_CASES_LIG; i++)\r\n    {\r\n        for(j=0; j<NB_CASES_COL; j++)\r\n        {\r\n            fprintf(fp,\"%d \",v->terrain[i][j]->type);\r\n        }\r\n        fprintf(fp,\"\\n\");\r\n    }\r\n    ///ON ECRIT LES INFORMATIONS DE LA COLLECTION D'HABITATION\r\n    fprintf(fp,\"%d\\n\",v->collec_habitations->taille_actuelle);\r\n    for(i=0; i<v->collec_habitations->taille_actuelle; i++)\r\n    {\r\n        fprintf(fp,\"%d %d %d %f %d\\n\",v->collec_habitations->habitation[i]->case_de_referenceX, v->collec_habitations->habitation[i]->case_de_referenceY,v->collec_habitations->habitation[i]->stade, v->collec_habitations->habitation[i]->chrono, v->collec_habitations->habitation[i]->feu);\r\n    }\r\n    fprintf(fp,\"\\n\\n\");\r\n    ///ON ECRIT LES INFORMATIONS DE LA COLLECTION DE CHATEAUX\r\n    fprintf(fp,\"%d\\n\",v->collec_chateaux->taille_actuelle);\r\n    for(i=0; i<v->collec_chateaux->taille_actuelle; i++)\r\n    {\r\n        fprintf(fp,\"%d %d\\n\",v->collec_chateaux->chateau[i]->case_de_referenceX,v->collec_chateaux->chateau[i]->case_de_referenceY);\r\n    }\r\n    fprintf(fp,\"\\n\\n\");\r\n    ///ON ECRIT LES INFORMATIONS DE LA COLLECTION DE CENTRALE\r\n    fprintf(fp,\"%d\\n\",v->collec_centrales->taille_actuelle);\r\n    for(i=0; i<v->collec_centrales->taille_actuelle; i++)\r\n    {\r\n        fprintf(fp,\"%d %d\\n\",v->collec_centrales->centrale[i]->case_de_referenceX,v->collec_centrales->centrale[i]->case_de_referenceY);\r\n    }\r\n    fprintf(fp,\"\\n\\n\");\r\n    ///ON ECRIT LES INFORMATIONS DE LA COLLECTION DE CASERNE\r\n    fprintf(fp,\"%d\\n\",v->collec_casernes->taille_actuelle);\r\n    for(i=0; i<v->collec_casernes->taille_actuelle; i++)\r\n    {\r\n        fprintf(fp,\"%d %d\\n\",v->collec_casernes->caserne[i]->case_de_referenceX,v->collec_casernes->caserne[i]->case_de_referenceY);\r\n    }\r\n    fclose(fp);\r\n}\r\n\r\nvoid ville_afficher(t_ville* v, int bouton_boite_a_outils)\r\n{\r\n    int i;\r\n    int img_utilisee;\r\n    int elec_distribue=0;\r\n    int l,c,compteur,eau_distribue=0;\r\n    int mx,my; // CHANGEMENT DE REFERENTIEL POUR CONNAITRE LES COORDONNEES DE LA SOURIS DANS LA SUB-BITMAP DE JEU\r\n    // (voir les premiers \"define\" de \"define.h\" -> \"GAME\"\r\n\r\n    int lig,col; // permet de savoir dans quelle case la souris est actuellement\r\n    t_habitation* tmp;\r\n    t_chateau* cha;\r\n    //t_habitation* tmp;\r\n    t_centrale* cent;\r\n    switch(v->niveau_visualisation)\r\n    {\r\n        case NIVEAU_SOL:\r\n\r\n\r\n            mx = mouse_x - GAME_POSX;\r\n            my = mouse_y - GAME_POSY;\r\n\r\n            lig = my / TAILLE_CASE;\r\n            col = mx / TAILLE_CASE;\r\n\r\n            draw_sprite(graphs->buffer_ville,graphs->fond_herbe,0,0);\r\n            draw_sprite(graphs->buffer_ville,graphs->grille,0,0);\r\n\r\n            // Affichage des routes. On est obligés de parcourir la matrice car on ne dispose pas de collection de routes\r\n            // Pour optimiser:\r\n            // - soit on fait une collection de routes\r\n            // - soit on parcourt la matrice pour tout afficher (préférable pour l'éventuelle 3D iso)\r\n            for(l=0; l<NB_CASES_LIG; l++)\r\n            {\r\n                for(c=0; c<NB_CASES_COL; c++)\r\n                {\r\n                    if(v->terrain[l][c]->type == ROUTE)\r\n                    {\r\n                        route_afficher(v->terrain[l][c]->elem,v->niveau_visualisation);\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            for(i=0;i<v->collec_habitations->taille_actuelle;i++) {\r\n\r\n\r\n                if (v->collec_habitations->habitation[i]->feu >= EN_FEU) {\r\n                    img_utilisee = 0;\r\n                } else {\r\n                    img_utilisee = 1;\r\n                }\r\n\r\n\r\n                switch (v->collec_habitations->habitation[i]->stade) {\r\n                    case 0:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->ruine,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->ruine,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 1:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->terrain_vague,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->terrain_vague,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 2:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->cabane[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->cabane[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 3:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->maison[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->maison[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 4:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->immeuble[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->immeuble[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 5:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->gratte_ciel[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->gratte_ciel[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                }\r\n                if ((v->collec_habitations->habitation[i]->feu) && (v->collec_habitations->habitation[i]->protegee)) {\r\n                    draw_sprite(graphs->buffer_ville, graphs->pompier,\r\n                                1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                }\r\n            }\r\n\r\n            for(i=0; i<v->collec_centrales->taille_actuelle; i++)\r\n            {\r\n                if(v->niveau_visualisation==NIVEAU_EAU)\r\n                {\r\n                    draw_trans_sprite(graphs->buffer_ville,graphs->centrale,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceY);\r\n                }\r\n                else\r\n                {\r\n                    draw_sprite(graphs->buffer_ville,graphs->centrale,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceY);\r\n                }\r\n            }\r\n\r\n            for(i=0; i<v->collec_chateaux->taille_actuelle; i++)\r\n            {\r\n\r\n                if(v->niveau_visualisation==NIVEAU_ELEC)\r\n                {\r\n                    draw_trans_sprite(graphs->buffer_ville,graphs->chateau,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceY);\r\n                }\r\n                else\r\n                {\r\n                    draw_sprite(graphs->buffer_ville,graphs->chateau,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceY);\r\n                }\r\n            }\r\n\r\n            for(i=0; i<v->collec_casernes->taille_actuelle; i++)\r\n            {\r\n                if(v->niveau_visualisation==NIVEAU_SOL)\r\n                {\r\n                    draw_sprite(graphs->buffer_ville,graphs->caserne,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceY);\r\n                }\r\n                draw_trans_sprite(graphs->buffer_ville,graphs->caserne,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceY);\r\n            }\r\n\r\n            // AFFICHAGE DE L'IMAGE TEMPORAIRE QUI SUIT LA SOURIS:\r\n            if(bouton_boite_a_outils == BOUTON_AJOUTER_ROUTE)\r\n            {\r\n                if((mx>0)&&(mx<GAME_W)&&(my>0)&&(my<GAME_H))\r\n                {\r\n                    if(route_place_libre(col,lig,v->terrain))\r\n                    {\r\n                        //draw_lit_sprite(graphs->buffer_ville,graphs->terrain_vague,1+TAILLE_CASE*col,1+TAILLE_CASE*lig,makecol(0,250,0));\r\n                        draw_sprite(graphs->buffer_ville,graphs->route[NIVEAU_SOL],1+TAILLE_CASE*col,1+TAILLE_CASE*lig);\r\n                    }\r\n                    else\r\n                    {\r\n                        draw_trans_sprite(graphs->buffer_ville,graphs->route[NIVEAU_SOL],1+TAILLE_CASE*col,1+TAILLE_CASE*lig);\r\n                    }\r\n                }\r\n            }\r\n            else if(bouton_boite_a_outils == BOUTON_AJOUTER_HABITATION)\r\n            {\r\n                if((mx>0)&&(mx<GAME_W)&&(my>0)&&(my<GAME_H))\r\n                {\r\n                    if(habitation_place_libre(col,lig,v->terrain))\r\n                    {\r\n                        draw_sprite(graphs->buffer_ville,graphs->terrain_vague,1+TAILLE_CASE*col,1+TAILLE_CASE*lig);\r\n                    }\r\n                    else\r\n                    {\r\n                        draw_trans_sprite(graphs->buffer_ville,graphs->terrain_vague,1+TAILLE_CASE*col,1+TAILLE_CASE*lig);\r\n                    }\r\n                }\r\n            }\r\n            else if(bouton_boite_a_outils == BOUTON_AJOUTER_CHATEAU)\r\n            {\r\n                if((mx>0)&&(mx<GAME_W)&&(my>0)&&(my<GAME_H))\r\n                {\r\n                    if(chateau_place_libre(col,lig,v->terrain))\r\n                    {\r\n                        draw_sprite(graphs->buffer_ville,graphs->chateau,1+TAILLE_CASE*col,1+TAILLE_CASE*lig);\r\n                    }\r\n                    else\r\n                    {\r\n                        draw_trans_sprite(graphs->buffer_ville,graphs->chateau,1+TAILLE_CASE*col,1+TAILLE_CASE*lig);\r\n                    }\r\n                }\r\n            }\r\n            else if(bouton_boite_a_outils == BOUTON_AJOUTER_CENTRALE)\r\n            {\r\n                if((mx>0)&&(mx<GAME_W)&&(my>0)&&(my<GAME_H))\r\n                {\r\n                    if(centrale_place_libre(col,lig,v->terrain))\r\n                    {\r\n                        draw_sprite(graphs->buffer_ville,graphs->centrale,1+TAILLE_CASE*col,1+TAILLE_CASE*lig);\r\n                    }\r\n                    else\r\n                    {\r\n                        draw_trans_sprite(graphs->buffer_ville,graphs->centrale,1+TAILLE_CASE*col,1+TAILLE_CASE*lig);\r\n                    }\r\n                }\r\n            }\r\n            else if(bouton_boite_a_outils == BOUTON_AJOUTER_CASERNE)\r\n            {\r\n                if((mx>0)&&(mx<GAME_W)&&(my>0)&&(my<GAME_H))\r\n                {\r\n                    if(caserne_place_libre(col,lig,v->terrain))\r\n                    {\r\n                        draw_sprite(graphs->buffer_ville,graphs->caserne,1+TAILLE_CASE*col,1+TAILLE_CASE*lig);\r\n                    }\r\n                    else\r\n                    {\r\n                        draw_trans_sprite(graphs->buffer_ville,graphs->caserne,1+TAILLE_CASE*col,1+TAILLE_CASE*lig);\r\n                    }\r\n                }\r\n            }\r\n            // FIN DE L'AFFICHAGE TEMPORAIRE QUI SUIT LA SOURIS\r\n\r\n            blit(graphs->buffer_ville,page, 0,0, GAME_POSX,GAME_POSY, GAME_W,GAME_H);\r\n            break;\r\n        case NIVEAU_EAU:\r\n\r\n\r\n            mx = mouse_x - GAME_POSX;\r\n            my = mouse_y - GAME_POSY;\r\n\r\n            lig = my / TAILLE_CASE;\r\n            col = mx / TAILLE_CASE;\r\n\r\n            draw_sprite(graphs->buffer_ville,graphs->fond_herbe,0,0);\r\n            draw_sprite(graphs->buffer_ville,graphs->grille,0,0);\r\n\r\n            for(l=0; l<NB_CASES_LIG; l++)\r\n            {\r\n                for(c=0; c<NB_CASES_COL; c++)\r\n                {\r\n                    if(v->terrain[l][c]->type == ROUTE)\r\n                    {\r\n                        route_afficher(v->terrain[l][c]->elem,v->niveau_visualisation);\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            for(i=0;i<v->collec_habitations->taille_actuelle;i++) {\r\n\r\n\r\n                if (v->collec_habitations->habitation[i]->feu >= EN_FEU) {\r\n                    img_utilisee = 0;\r\n                } else {\r\n                    img_utilisee = 1;\r\n                }\r\n\r\n\r\n                switch (v->collec_habitations->habitation[i]->stade) {\r\n                    case 0:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->ruine,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->ruine,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 1:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->terrain_vague,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->terrain_vague,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 2:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->cabane[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->cabane[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 3:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->maison[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->maison[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 4:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->immeuble[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->immeuble[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 5:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->gratte_ciel[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->gratte_ciel[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                }\r\n                if ((v->collec_habitations->habitation[i]->feu) && (v->collec_habitations->habitation[i]->protegee)) {\r\n                    draw_sprite(graphs->buffer_ville, graphs->pompier,\r\n                                1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                }\r\n            }\r\n\r\n            for(i=0; i<v->collec_centrales->taille_actuelle; i++)\r\n            {\r\n                if(v->niveau_visualisation==NIVEAU_EAU)\r\n                {\r\n                    draw_trans_sprite(graphs->buffer_ville,graphs->centrale,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceY);\r\n                }\r\n                else\r\n                {\r\n                    draw_sprite(graphs->buffer_ville,graphs->centrale,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceY);\r\n                }\r\n            }\r\n\r\n            for(i=0; i<v->collec_chateaux->taille_actuelle; i++)\r\n            {\r\n\r\n                if(v->niveau_visualisation==NIVEAU_ELEC)\r\n                {\r\n                    draw_trans_sprite(graphs->buffer_ville,graphs->chateau,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceY);\r\n                }\r\n                else\r\n                {\r\n                    draw_sprite(graphs->buffer_ville,graphs->chateau,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceY);\r\n                }\r\n            }\r\n\r\n            for(i=0; i<v->collec_casernes->taille_actuelle; i++)\r\n            {\r\n                if(v->niveau_visualisation==NIVEAU_SOL)\r\n                {\r\n                    draw_sprite(graphs->buffer_ville,graphs->caserne,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceY);\r\n                }\r\n                draw_trans_sprite(graphs->buffer_ville,graphs->caserne,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceY);\r\n            }\r\n\r\n            for(compteur=0; compteur<v->collec_chateaux->taille_actuelle; compteur++)\r\n            {\r\n                cha=v->collec_chateaux->chateau[compteur];\r\n                textprintf_ex(graphs->buffer_ville,font,1+TAILLE_CASE*cha->case_de_referenceX,1+TAILLE_CASE*cha->case_de_referenceY+(CHATEAU_H*TAILLE_CASE/2),makecol(0,0,0),-1,\"Chateau %d-%d :\",cha->id_chateau.caseX,cha->id_chateau.caseY);\r\n                textprintf_ex(graphs->buffer_ville,font,1+TAILLE_CASE*cha->case_de_referenceX,1+TAILLE_CASE*cha->case_de_referenceY+(CHATEAU_H*TAILLE_CASE/2)+TAILLE_POLICE,makecol(0,0,0),-1,\"%d/%d\",cha->capacite.capacite_disponible,cha->capacite.capacite_max);\r\n            }\r\n\r\n            if((mx>0)&&(mx<GAME_W)&&(my>0)&&(my<GAME_H))\r\n            {\r\n                if((v->terrain[lig][col]->type==HABITATION))\r\n                {\r\n                    tmp=((t_habitation*) v->terrain[lig][col]->elem);\r\n                    for(compteur=0; compteur<FOURNISSEUR_MAX; compteur++)\r\n                    {\r\n                        eau_distribue+=tmp->chateaux_fournisseurs[compteur].qte_eau_distribuee;\r\n                    }\r\n                    textprintf_ex(graphs->buffer_ville,font,1+TAILLE_CASE*tmp->case_de_referenceX,1+TAILLE_CASE*tmp->case_de_referenceY,makecol(0,100,255),-1,\"%d/%d\",eau_distribue,habitation_nbhabitants(tmp));\r\n                    compteur=0;\r\n                    while((tmp->chateaux_fournisseurs[compteur].qte_eau_distribuee != 0) && (compteur<FOURNISSEUR_MAX))\r\n                    {\r\n                        textprintf_ex(graphs->buffer_ville,font,1+TAILLE_CASE*tmp->case_de_referenceX,1+TAILLE_CASE*tmp->case_de_referenceY+(compteur+1)*TAILLE_POLICE,makecol(255,255,255),-1,\"Chateau %d-%d : %d\",tmp->chateaux_fournisseurs[compteur].id_fournisseur.caseX,tmp->chateaux_fournisseurs[compteur].id_fournisseur.caseY,tmp->chateaux_fournisseurs[compteur].qte_eau_distribuee);\r\n                        compteur++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            blit(graphs->buffer_ville,page, 0,0, GAME_POSX,GAME_POSY, GAME_W,GAME_H);\r\n            break;\r\n        case NIVEAU_ELEC:\r\n\r\n            /*int mx,my; // CHANGEMENT DE REFERENTIEL POUR CONNAITRE LES COORDONNEES DE LA SOURIS DANS LA SUB-BITMAP DE JEU\r\n            // (voir les premiers \"define\" de \"define.h\" -> \"GAME\"\r\n\r\n            int lig,col; // permet de savoir dans quelle case la souris est actuellement\r\n            */\r\n\r\n            mx = mouse_x - GAME_POSX;\r\n            my = mouse_y - GAME_POSY;\r\n\r\n            lig = my / TAILLE_CASE;\r\n            col = mx / TAILLE_CASE;\r\n\r\n            draw_sprite(graphs->buffer_ville,graphs->fond_herbe,0,0);\r\n            draw_sprite(graphs->buffer_ville,graphs->grille,0,0);\r\n\r\n            for(l=0; l<NB_CASES_LIG; l++)\r\n            {\r\n                for(c=0; c<NB_CASES_COL; c++)\r\n                {\r\n                    if(v->terrain[l][c]->type == ROUTE)\r\n                    {\r\n                        route_afficher(v->terrain[l][c]->elem,v->niveau_visualisation);\r\n                    }\r\n                }\r\n            }\r\n\r\n            int i;\r\n            int img_utilisee;\r\n            for(i=0;i<v->collec_habitations->taille_actuelle;i++) {\r\n\r\n\r\n                if (v->collec_habitations->habitation[i]->feu >= EN_FEU) {\r\n                    img_utilisee = 0;\r\n                } else {\r\n                    img_utilisee = 1;\r\n                }\r\n\r\n\r\n                switch (v->collec_habitations->habitation[i]->stade) {\r\n                    case 0:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->ruine,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->ruine,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 1:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->terrain_vague,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->terrain_vague,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 2:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->cabane[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->cabane[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 3:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->maison[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->maison[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 4:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->immeuble[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->immeuble[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                    case 5:\r\n                        if (((v->niveau_visualisation == NIVEAU_EAU) && (!v->collec_habitations->habitation[i]->eau)) ||\r\n                            ((v->niveau_visualisation == NIVEAU_ELEC) &&\r\n                             (!v->collec_habitations->habitation[i]->electricite))) {\r\n                            draw_lit_sprite(graphs->buffer_ville, graphs->gratte_ciel[img_utilisee],\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                            1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY,\r\n                                            makecol(255, 0, 0));\r\n                        } else\r\n                            draw_sprite(graphs->buffer_ville, graphs->gratte_ciel[img_utilisee],\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                        1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                        break;\r\n                }\r\n                if ((v->collec_habitations->habitation[i]->feu) && (v->collec_habitations->habitation[i]->protegee)) {\r\n                    draw_sprite(graphs->buffer_ville, graphs->pompier,\r\n                                1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceX,\r\n                                1 + TAILLE_CASE * v->collec_habitations->habitation[i]->case_de_referenceY);\r\n                }\r\n            }\r\n            for(i=0; i<v->collec_centrales->taille_actuelle; i++)\r\n            {\r\n                if(v->niveau_visualisation==NIVEAU_EAU)\r\n                {\r\n                    draw_trans_sprite(graphs->buffer_ville,graphs->centrale,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceY);\r\n                }\r\n                else\r\n                {\r\n                    draw_sprite(graphs->buffer_ville,graphs->centrale,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_centrales->centrale[i]->case_de_referenceY);\r\n                }\r\n            }\r\n\r\n            for(i=0; i<v->collec_chateaux->taille_actuelle; i++)\r\n            {\r\n\r\n                if(v->niveau_visualisation==NIVEAU_ELEC)\r\n                {\r\n                    draw_trans_sprite(graphs->buffer_ville,graphs->chateau,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceY);\r\n                }\r\n                else\r\n                {\r\n                    draw_sprite(graphs->buffer_ville,graphs->chateau,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_chateaux->chateau[i]->case_de_referenceY);\r\n                }\r\n            }\r\n\r\n            for(i=0; i<v->collec_casernes->taille_actuelle; i++)\r\n            {\r\n                if(v->niveau_visualisation==NIVEAU_SOL)\r\n                {\r\n                    draw_sprite(graphs->buffer_ville,graphs->caserne,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceY);\r\n                }\r\n                draw_trans_sprite(graphs->buffer_ville,graphs->caserne,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceX,1+TAILLE_CASE*v->collec_casernes->caserne[i]->case_de_referenceY);\r\n            }\r\n\r\n            for(compteur=0; compteur<v->collec_centrales->taille_actuelle; compteur++)\r\n            {\r\n                cent=v->collec_centrales->centrale[compteur];\r\n                textprintf_ex(graphs->buffer_ville,font,1+TAILLE_CASE*cent->case_de_referenceX,1+TAILLE_CASE*cent->case_de_referenceY+(CENTRALE_H*TAILLE_CASE/2),makecol(0,0,0),-1,\"Centrale %d-%d :\",cent->id_centrale.caseX,cent->id_centrale.caseY);\r\n                textprintf_ex(graphs->buffer_ville,font,1+TAILLE_CASE*cent->case_de_referenceX,1+TAILLE_CASE*cent->case_de_referenceY+(CENTRALE_H*TAILLE_CASE/2)+TAILLE_POLICE,makecol(0,0,0),-1,\"%d/%d\",cent->capacite.capacite_disponible,cent->capacite.capacite_max);\r\n            }\r\n\r\n            if((mx>0)&&(mx<GAME_W)&&(my>0)&&(my<GAME_H))\r\n            {\r\n                if((v->terrain[lig][col]->type==HABITATION))\r\n                {\r\n                    tmp=((t_habitation*) v->terrain[lig][col]->elem);\r\n                    if(tmp->electricite)\r\n                    {\r\n                        elec_distribue=habitation_nbhabitants(tmp);\r\n                    }\r\n                    else elec_distribue=0;\r\n                    textprintf_ex(graphs->buffer_ville,font,1+TAILLE_CASE*tmp->case_de_referenceX,1+TAILLE_CASE*tmp->case_de_referenceY,makecol(255,255,255),-1,\"%d/%d\",elec_distribue,habitation_nbhabitants(tmp));\r\n                    textprintf_ex(graphs->buffer_ville,font,1+TAILLE_CASE*tmp->case_de_referenceX,1+TAILLE_CASE*tmp->case_de_referenceY+TAILLE_POLICE,makecol(255,255,255),-1,\"Centrale %d-%d : %d\",tmp->id_centrale_fournisseuse.caseX,tmp->id_centrale_fournisseuse.caseY,elec_distribue);\r\n                }\r\n            }\r\n\r\n            blit(graphs->buffer_ville,page, 0,0, GAME_POSX,GAME_POSY, GAME_W,GAME_H);\r\n            break;\r\n    }\r\n}\r\n\r\nvoid ville_gerer(t_ville* v, int bouton_boite_a_outil)\r\n{\r\n    int** longueurs_casernes;\r\n    int** longueurs_chateaux;\r\n    int** longueurs_centrales;\r\n    int* capacite_centrale;\r\n    int* capacite_chateaux;\r\n    int i;\r\n    int j;\r\n\r\n    if(v->pause == PAUSE_DESACTIVEE)\r\n    {\r\n        // Actions à effectuer à chaque tour de boucle\r\n        clock_t temps_actuel = clock();\r\n\r\n        if(      (((double)(temps_actuel- v->timer))/CLOCKS_PER_SEC)    >=    PAS_DU_TIMER   )\r\n        {\r\n            v->timer = temps_actuel;\r\n            if(v->pause == PAUSE_DESACTIVEE)\r\n            {\r\n                date_actualiser(v->temps_de_jeu);\r\n\r\n\r\n                for(j=0;j<v->collec_habitations->taille_actuelle;j++)\r\n                {\r\n                    v->collec_habitations->habitation[j]->chrono = v->collec_habitations->habitation[j]->chrono + PAS_DU_TIMER;\r\n                }\r\n            }\r\n        }\r\n\r\n        collection_habitation_debut_tour(v->collec_habitations,&(v->nb_habitants));\r\n\r\n        for(i=0; i<v->collec_centrales->taille_actuelle; i++)\r\n        {\r\n            v->collec_centrales->centrale[i]->capacite.capacite_disponible = CAPACITE_CENTRALE;\r\n        }\r\n\r\n        for(i=0; i<v->collec_chateaux->taille_actuelle; i++)\r\n        {\r\n            v->collec_chateaux->chateau[i]->capacite.capacite_disponible=CAPACITE_CHATEAU;\r\n        }\r\n\r\n        ///Calcul des longueurs entre les habitations et les différents batiments\r\n        longueurs_chateaux=collection_chateau_tableau_longueurs(v->collec_chateaux,v->terrain,&(v->data_bfs),v->collec_habitations);\r\n        longueurs_centrales=collection_centrale_tableau_longueurs(v->collec_centrales,v->terrain,&(v->data_bfs),v->collec_habitations);\r\n        longueurs_casernes=collection_casernes_tableau_longueurs(v->collec_casernes,v->terrain,&(v->data_bfs),v->collec_habitations);\r\n\r\n        ///distribution de l'eau et de l'électicité et protection des incendies\r\n        collection_centrale_distribuer(v->collec_centrales,v->collec_habitations,longueurs_centrales);\r\n        collection_chateau_distribuer(v->collec_chateaux,v->collec_habitations,longueurs_chateaux);\r\n        collection_casernes_proteger(v->collec_casernes,v->collec_habitations,longueurs_casernes);\r\n\r\n        /** On tient à jour la qté d'eau et d'elec disponible **/\r\n        v->qte_eau.capacite_disponible = collection_chateau_eau_disponible(v->collec_chateaux);\r\n        v->qte_eau.capacite_max = CAPACITE_CHATEAU * v->collec_chateaux->taille_actuelle;\r\n\r\n        v->qte_elec.capacite_disponible = collection_centrale_elec_disponible(v->collec_centrales);\r\n        v->qte_elec.capacite_max = CAPACITE_CENTRALE * v->collec_centrales->taille_actuelle;\r\n\r\n        capacite_chateaux=collection_chateau_tableau_capacite(v->collec_chateaux);\r\n        capacite_centrale=collection_centrale_tableau_capacite(v->collec_centrales);\r\n\r\n        collection_habitation_evolution(v->collec_habitations,v->mode,&(v->argent),v->collec_chateaux->taille_actuelle,v->collec_centrales->taille_actuelle,longueurs_chateaux,longueurs_centrales,capacite_chateaux,capacite_centrale);\r\n\r\n        ///LIBERATION MEMOIRE DES TABLEAUX DYNAMIQUES ALLOUES\r\n        for(i=0; i<v->collec_centrales->taille_actuelle; i++)\r\n        {\r\n            free(longueurs_centrales[i]);\r\n        }\r\n        free(longueurs_centrales);\r\n        free(capacite_centrale);\r\n\r\n        for(i=0; i<v->collec_chateaux->taille_actuelle; i++)\r\n        {\r\n            free(longueurs_chateaux[i]);\r\n        }\r\n        free(longueurs_chateaux);\r\n        free(capacite_chateaux);\r\n\r\n        for(i=0; i<v->collec_casernes->taille_actuelle; i++)\r\n        {\r\n            free(longueurs_casernes[i]);\r\n        }\r\n        free(longueurs_casernes);\r\n\r\n    }\r\n\r\n\r\n    // Actions utilisateur\r\n    int mx,my; // CHANGEMENT DE REFERENTIEL POUR CONNAITRE LES COORDONNEES DE LA SOURIS DANS LA SUB-BITMAP DE JEU\r\n    // (voir les premiers \"define\" de \"define.h\" -> \"GAME\"\r\n\r\n    int lig,col; // permet de savoir dans quelle case la souris est actuellement\r\n\r\n    char chemin[TAILLE_CHAINE];\r\n\r\n    t_habitation* habitation;\r\n    t_chateau* chateau;\r\n    t_centrale* centrale;\r\n    t_caserne* caserne;\r\n\r\n    mx = mouse_x - GAME_POSX;\r\n    my = mouse_y - GAME_POSY;\r\n\r\n    lig = my / TAILLE_CASE;\r\n    col = mx / TAILLE_CASE;\r\n\r\n    if((bouton_boite_a_outil == BOUTON_AJOUTER_ROUTE) && (v->pause != PAUSE_ACTIVEE) && (v->niveau_visualisation == NIVEAU_SOL))\r\n    {\r\n        if(mouse_b&1 && v->argent >= COUT_ROUTE)\r\n        {\r\n            if(route_place_libre(col,lig,v->terrain))\r\n            {\r\n                route_placer(route_creer(),col,lig,v->terrain);\r\n                v->argent-= COUT_ROUTE;\r\n            }\r\n        }\r\n    }\r\n    else if((bouton_boite_a_outil == BOUTON_AJOUTER_HABITATION) && (v->pause != PAUSE_ACTIVEE) && (v->niveau_visualisation == NIVEAU_SOL))\r\n    {\r\n        if(bouton == 'g' && v->argent >= COUT_HABITATION)\r\n        {\r\n            if(habitation_place_libre(col,lig,v->terrain))\r\n            {\r\n                habitation=habitation_creer();\r\n                habitation_placer(habitation,col,lig,v->terrain);\r\n                collection_habitation_ajouter_habitation(v->collec_habitations,habitation);\r\n                v->argent -= COUT_HABITATION;\r\n            }\r\n        }\r\n    }\r\n    else if((bouton_boite_a_outil == BOUTON_AJOUTER_CHATEAU) && (v->pause != PAUSE_ACTIVEE) && (v->niveau_visualisation == NIVEAU_SOL))\r\n    {\r\n        if(bouton == 'g' && v->argent >= COUT_CHATEAU)\r\n        {\r\n            if(chateau_place_libre(col,lig,v->terrain))\r\n            {\r\n                chateau=chateau_creer();\r\n                int i,j;\r\n                chateau->case_de_referenceX=col;\r\n                chateau->case_de_referenceY=lig;\r\n                chateau->id_chateau.caseX = col;\r\n                chateau->id_chateau.caseY = lig;\r\n                for(i=col;i<col+CHATEAU_W;i++)\r\n                {\r\n                    for(j=lig;j<lig+CHATEAU_H;j++)\r\n                    {\r\n                        v->terrain[j][i]->type=CHATEAU;\r\n                        v->terrain[j][i]->elem=chateau;\r\n                    }\r\n                }\r\n                collection_chateau_ajouter_chateau(v->collec_chateaux,chateau);\r\n                v->argent -= COUT_CHATEAU;\r\n            }\r\n        }\r\n    }\r\n    else if((bouton_boite_a_outil == BOUTON_AJOUTER_CENTRALE) && (v->pause != PAUSE_ACTIVEE) && (v->niveau_visualisation == NIVEAU_SOL))\r\n    {\r\n        if(bouton == 'g' && v->argent >= COUT_CENTRALE)\r\n        {\r\n            if(centrale_place_libre(col,lig,v->terrain))\r\n            {\r\n                centrale=centrale_creer();\r\n                int o,p;\r\n                centrale->case_de_referenceX=col;\r\n                centrale->case_de_referenceY=lig;\r\n                centrale->id_centrale.caseX = col;\r\n                centrale->id_centrale.caseY = lig;\r\n                for(o=lig;o<lig+CENTRALE_H;o++)\r\n                {\r\n                    for(p=col;p<col+CENTRALE_W;p++)\r\n                    {\r\n                        v->terrain[o][p]->type=CENTRALE;\r\n                        v->terrain[o][p]->elem=centrale;\r\n                    }\r\n                }\r\n                collection_centrale_ajouter_centrale(v->collec_centrales,centrale);\r\n                v->argent -= COUT_CENTRALE;\r\n            }\r\n        }\r\n    }\r\n    else if((bouton_boite_a_outil == BOUTON_AJOUTER_CASERNE) && (v->pause != PAUSE_ACTIVEE) && (v->niveau_visualisation == NIVEAU_SOL))\r\n    {\r\n        if(bouton == 'g' && v->argent >= COUT_CASERNE)\r\n        {\r\n            if(caserne_place_libre(col,lig,v->terrain))\r\n            {\r\n                caserne=caserne_creer();\r\n\r\n                int i,j;\r\n                caserne->case_de_referenceX=col;\r\n                caserne->case_de_referenceY=lig;\r\n                for(i=col;i<col+CASERNE_W;i++)\r\n                {\r\n                    for(j=lig;j<lig+CASERNE_H;j++)\r\n                    {\r\n                        v->terrain[j][i]->type=CASERNE;\r\n                        v->terrain[j][i]->elem=caserne;\r\n                    }\r\n                }\r\n                collection_casernes_ajouter_caserne(v->collec_casernes,caserne);\r\n                v->argent -= COUT_CENTRALE;\r\n            }\r\n        }\r\n    }\r\n    else if(bouton_boite_a_outil == BOUTON_PAUSE) // || (touche == 'p') ne fonctionne pas toujours, souci compalleg\r\n    {\r\n        v->pause = !(v->pause);\r\n    }\r\n    else if(bouton_boite_a_outil == BOUTON_SAUVEGARDER)\r\n    {\r\n        if(remplit_chemin_sauvegarde(chemin))\r\n            ville_sauvegarder(chemin, v);\r\n    }\r\n    else if(bouton_boite_a_outil == BOUTON_NIVEAU_SOL)\r\n    {\r\n        v->pause = PAUSE_DESACTIVEE;\r\n        v->niveau_visualisation = NIVEAU_SOL;\r\n    }\r\n    else if(bouton_boite_a_outil == BOUTON_NIVEAU_EAU)\r\n    {\r\n        v->pause = PAUSE_ACTIVEE;\r\n        v->niveau_visualisation = NIVEAU_EAU;\r\n    }\r\n    else if(bouton_boite_a_outil == BOUTON_NIVEAU_ELEC)\r\n    {\r\n        v->pause = PAUSE_ACTIVEE;\r\n        v->niveau_visualisation = NIVEAU_ELEC;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mabiblio.c b/mabiblio.c
--- a/mabiblio.c	(revision d307db92086f734c5e091295b17a3ab42ba9f5fd)
+++ b/mabiblio.c	(date 1669501681563)
@@ -2067,7 +2067,10 @@
 /////////////////menu.c////////////////////////
 void menu(BITMAP* menu1, t_graphMenu* graph)
 {
+    BITMAP* menuFR;
     int son=1;
+
+    rafraichir_clavier_souris();
     graph->music = chargerSon("fichiers/sound.wav");//initialisation du son
     play_sample(graph->music, 255, 127, 1000, 1); //jouer la musique
     while(!key[KEY_ESC])
@@ -2083,17 +2086,23 @@
             stop_sample(graph->music);
         }
         blit(menu1, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);//on affiche le menu de choix des langues
+        //afficher_page();
         if((mouse_b&1) && (mouse_x >= 120) && (mouse_x <= 350) && (mouse_y >= 300) && (mouse_y <= 550))//si l'utilisateur a cliqué sur le drapeau du RU
         {
             //chargement des bitmap anglaises
         }
         else if((mouse_b&1) && (mouse_x >= 480) && (mouse_x <= 850) && (mouse_y >= 380) && (mouse_y <= 820))//le clic se situe sur le drapeau français
         {
-            BITMAP* menuFR=chargerImage("fichiers/images/menu1/menuFR/menu2FR.bmp");//chargement des bitmap françaises
+
+            menuFR=chargerImage("fichiers/images/menu1/menuFR/menu2FR.bmp");//chargement des bitmap françaises
             menuBisFR(menu1, menuFR,  graph);//on lance le jeu en français
+
             destroy_bitmap(menuFR);
+
         }
+
     }
+    rest(20);
 }
 
 int menuModeFR(BITMAP* menufr, BITMAP* menuModefr, t_graphMenu* graph)//menu choix du mode
@@ -2104,13 +2113,13 @@
     blit(menuModefr, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);//on affiche le menu de choix du mode communiste/capitaliste
     while(quitter == -1)
     {
-        if ((mouse_b & 1) && (mouse_x >= 0) && (mouse_x <= 470) && (mouse_y >= 300) && (mouse_y <= 500))//si l'utilisateur a cliqué sur les règles
+        if ((mouse_b&1) && (mouse_x >= 0) && (mouse_x <= 470) && (mouse_y >= 300) && (mouse_y <= 500))//si l'utilisateur a cliqué sur les règles
         {
             printf("mode communiste\n");
             mode=MODE_COMMUNISTE;//jeu en mode communiste
             quitter=1;
         }
-        else if ((mouse_b & 1) && (mouse_x >= 550) && (mouse_x <= 1024) && (mouse_y >= 300) && (mouse_y <= 500))//si l'utilisateur a cliqué sur les règles
+        else if ((mouse_b&1) && (mouse_x >= 550) && (mouse_x <= 1024) && (mouse_y >= 300) && (mouse_y <= 500))//si l'utilisateur a cliqué sur les règles
         {
             printf("mode capitaliste\n");
             mode=MODE_CAPITALISTE;//jeu en mode capitaliste
@@ -2124,9 +2133,12 @@
 void menuBisFR(BITMAP* menu1, BITMAP* menuFR, t_graphMenu* graph)
 {
     int choix;
-    BITMAP* menufr=chargerImage("fichiers/images/menu1/menuFR/menu2FR.bmp");//chargement des bitmap anglaises
-    BITMAP* menuModefr=chargerImage("fichiers/images/menu1/menuFR/menuModeFR.bmp");
-    BITMAP* menuReglesfr=chargerImage("fichiers/images/menu1/menuFR/menuReglesFR.bmp");
+    BITMAP* menufr;
+    BITMAP* menuModefr;
+    BITMAP* menuReglesfr;
+    menufr=chargerImage("fichiers/images/menu1/menuFR/menu2FR.bmp");//chargement des bitmap anglaises
+    menuModefr=chargerImage("fichiers/images/menu1/menuFR/menuModeFR.bmp");
+    menuReglesfr=chargerImage("fichiers/images/menu1/menuFR/menuReglesFR.bmp");
     blit(menufr, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);//on affiche le menu en français
     while(!key[KEY_ESC])
     {
@@ -2163,6 +2175,7 @@
             menuReglesFR(menufr, menuReglesfr, menu1, graph);//on affiche les règles du jeu
         }
     }
+
 }
 
 void menuReglesFR(BITMAP* menufr, BITMAP* menuReglesfr, BITMAP* menu1, t_graphMenu* graph)//affichage des règles du jeu
@@ -2180,7 +2193,9 @@
 void menu_boucle_jeu(int mode,const char* nom_fichier,t_graphMenu graph)
 {
     int quitte,son;
+    int quitquestion=0;
     quitte=0;
+
     son=0;
     t_editeur* ed = NULL;
     switch(mode)
@@ -2192,8 +2207,8 @@
             ed = editeur_allouer(MODE_COMMUNISTE);
             break;
         case CHARGER:
-            ed = editeur_allouer(MODE_CAPITALISTE); // osef on va le changer en chargeant la ville
-            ville_charger(nom_fichier,ed->maville);
+            //ed = editeur_allouer(MODE_CAPITALISTE); // osef on va le changer en chargeant la ville
+            //ville_charger(nom_fichier,ed->maville);
             break;
     }
     while((!key[KEY_ESC])&&(quitte != 1))
@@ -2210,7 +2225,7 @@
         }
         rafraichir_clavier_souris();
         editeur_gerer(ed);
-        quitte=editeur_afficher(ed);
+        quitte=editeur_afficher(ed,&quitquestion);
         rest(0.1);
     }
     editeur_liberer(ed);
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"CMakePresetLoader\">{\r\n  &quot;useNewFormat&quot;: true\r\n}</component>\r\n  <component name=\"CMakeReloadState\">\r\n    <option name=\"reloaded\" value=\"true\" />\r\n  </component>\r\n  <component name=\"CMakeRunConfigurationManager\">\r\n    <generated>\r\n      <config projectName=\"ECECITY\" targetName=\"ECECITY\" />\r\n    </generated>\r\n  </component>\r\n  <component name=\"CMakeSettings\" AUTO_RELOAD=\"true\">\r\n    <configurations>\r\n      <configuration PROFILE_NAME=\"Debug\" ENABLED=\"true\" CONFIG_NAME=\"Debug\" />\r\n    </configurations>\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"fc94bb9e-1034-4f8c-9aa0-0e9b41f0f01e\" name=\"Changes\" comment=\"ajout graphique\">\r\n      <change afterPath=\"$PROJECT_DIR$/fichiers/images/jeu/route0.bmp\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/fichiers/images/jeu/route1.bmp\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/fichiers/images/jeu/route2.bmp\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/fichiers/save.txt\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_19_11_2022_13_16_[Changes]/shelved.patch\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_19_11_2022_13_16__Changes_.xml\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/CMakeLists.txt\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/CMakeLists.txt\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-0.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-1.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-10.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-2.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-3.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-4.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-5.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-6.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-7.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-8.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route0-9.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-0.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-1.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-10.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-2.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-3.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-4.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-5.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-6.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-7.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-8.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route1-9.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-0.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-1.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-10.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-2.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-3.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-4.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-5.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-6.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-7.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-8.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/fichiers/images/jeu/route2-9.bmp\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/mabiblio.c\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/mabiblio.c\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/mabiblio.h\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/mabiblio.h\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/mesfonctions.c\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/mesfonctions.c\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ClangdSettings\">\r\n    <option name=\"clangTidyViaClangd\" value=\"false\" />\r\n    <option name=\"formatViaClangd\" value=\"false\" />\r\n  </component>\r\n  <component name=\"ExecutionTargetManager\" SELECTED_TARGET=\"CMakeBuildProfile:Debug\" />\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n    <option name=\"UPDATE_TYPE\" value=\"REBASE\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectApplicationVersion\">\r\n    <option name=\"ide\" value=\"CLion\" />\r\n    <option name=\"majorVersion\" value=\"2022\" />\r\n    <option name=\"minorVersion\" value=\"2.4\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"2HdO0y50ONb9b2PnHgNoYLRLkUn\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;ASKED_ADD_EXTERNAL_FILES&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.cidr.known.project.marker&quot;: &quot;true&quot;,\r\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\r\n    &quot;cf.first.check.clang-format&quot;: &quot;false&quot;,\r\n    &quot;cidr.known.project.marker&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/antoi/Downloads/ECECITY&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.pluginManager&quot;,\r\n    &quot;structure.view.defaults.are.configured&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\">\r\n    <configuration default=\"true\" type=\"CLionExternalRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\">\r\n      <method v=\"2\">\r\n        <option name=\"CLION.EXTERNAL.BUILD\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"ECECITY\" type=\"CMakeRunConfiguration\" factoryName=\"Application\" REDIRECT_INPUT=\"false\" ELEVATE=\"false\" USE_EXTERNAL_CONSOLE=\"false\" PASS_PARENT_ENVS_2=\"true\" PROJECT_NAME=\"ECECITY\" TARGET_NAME=\"ECECITY\" CONFIG_NAME=\"Debug\" RUN_TARGET_PROJECT_NAME=\"ECECITY\" RUN_TARGET_NAME=\"ECECITY\">\r\n      <method v=\"2\">\r\n        <option name=\"com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"fc94bb9e-1034-4f8c-9aa0-0e9b41f0f01e\" name=\"Changes\" comment=\"amelioration du travail d'antoine\" />\r\n      <created>1668611274360</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1668611274360</updated>\r\n      <workItem from=\"1668611275563\" duration=\"129000\" />\r\n      <workItem from=\"1668615624900\" duration=\"592000\" />\r\n      <workItem from=\"1668773862238\" duration=\"2017000\" />\r\n      <workItem from=\"1668777580595\" duration=\"102000\" />\r\n      <workItem from=\"1668860006219\" duration=\"1696000\" />\r\n      <workItem from=\"1668865665858\" duration=\"351000\" />\r\n      <workItem from=\"1668934427105\" duration=\"685000\" />\r\n      <workItem from=\"1668940728080\" duration=\"7182000\" />\r\n      <workItem from=\"1669024063147\" duration=\"438000\" />\r\n      <workItem from=\"1669024993634\" duration=\"303000\" />\r\n      <workItem from=\"1669034775124\" duration=\"388000\" />\r\n      <workItem from=\"1669102785117\" duration=\"1189000\" />\r\n      <workItem from=\"1669118598660\" duration=\"1191000\" />\r\n      <workItem from=\"1669208122560\" duration=\"1451000\" />\r\n      <workItem from=\"1669209954230\" duration=\"6247000\" />\r\n      <workItem from=\"1669228417795\" duration=\"5714000\" />\r\n      <workItem from=\"1669361003270\" duration=\"6485000\" />\r\n      <workItem from=\"1669369012843\" duration=\"4985000\" />\r\n      <workItem from=\"1669382220064\" duration=\"1496000\" />\r\n      <workItem from=\"1669407969325\" duration=\"2175000\" />\r\n      <workItem from=\"1669478161078\" duration=\"135000\" />\r\n      <workItem from=\"1669478320218\" duration=\"13825000\" />\r\n      <workItem from=\"1669494965278\" duration=\"82000\" />\r\n      <workItem from=\"1669495059756\" duration=\"614000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"amelioration du travail d'antoine\">\r\n      <created>1668615690545</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1668615690545</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"accesibilité menu\">\r\n      <created>1668963204470</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1668963204470</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"compacteV2\">\r\n      <created>1669302755148</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669302755148</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"ajout graphique\">\r\n      <created>1669372254939</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1669372254939</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"5\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.History.Properties\">\r\n    <option name=\"COLUMN_ID_ORDER\">\r\n      <list>\r\n        <option value=\"Default.Root\" />\r\n        <option value=\"Default.Author\" />\r\n        <option value=\"Default.Date\" />\r\n        <option value=\"Default.Subject\" />\r\n        <option value=\"Space.CommitStatus\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\r\n    <MESSAGE value=\"amelioration du travail d'antoine\" />\r\n    <MESSAGE value=\"accesibilité menu\" />\r\n    <MESSAGE value=\"compacteV2\" />\r\n    <MESSAGE value=\"ajout graphique\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"ajout graphique\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision d307db92086f734c5e091295b17a3ab42ba9f5fd)
+++ b/.idea/workspace.xml	(date 1669538592276)
@@ -17,51 +17,23 @@
     </configurations>
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="fc94bb9e-1034-4f8c-9aa0-0e9b41f0f01e" name="Changes" comment="ajout graphique">
-      <change afterPath="$PROJECT_DIR$/fichiers/images/jeu/route0.bmp" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/fichiers/images/jeu/route1.bmp" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/fichiers/images/jeu/route2.bmp" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/fichiers/save.txt" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_19_11_2022_13_16_[Changes]/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_19_11_2022_13_16__Changes_.xml" beforeDir="false" />
+    <list default="true" id="fc94bb9e-1034-4f8c-9aa0-0e9b41f0f01e" name="Changes" comment="geographie">
+      <change afterPath="$PROJECT_DIR$/fichiers/images/menu/menu1/menuAN/menu2AN.bmp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/fichiers/images/menu/menu1/menuAN/menuModeAN.bmp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/fichiers/images/menu/menu1/menuAN/menuReglesAN.bmp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/fichiers/images/menu/menu1/menuChoixLangues.bmp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/fichiers/images/menu/menu1/menuFR/menu2FR.bmp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/fichiers/images/menu/menu1/menuFR/menuModeFR.bmp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/fichiers/images/menu/menu1/menuFR/menuReglesFR.bmp" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/CMakeLists.txt" beforeDir="false" afterPath="$PROJECT_DIR$/CMakeLists.txt" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-0.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-1.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-10.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-2.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-3.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-4.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-5.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-6.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-7.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-8.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route0-9.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-0.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-1.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-10.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-2.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-3.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-4.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-5.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-6.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-7.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-8.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route1-9.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-0.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-1.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-10.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-2.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-3.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-4.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-5.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-6.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-7.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-8.bmp" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/fichiers/images/jeu/route2-9.bmp" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/fichiers/images/menu1/menuAN/menu2AN.bmp" beforeDir="false" afterPath="$PROJECT_DIR$/fichiers/images/menu/menu/menu1/menuAN/menu2AN.bmp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/fichiers/images/menu1/menuAN/menuModeAN.bmp" beforeDir="false" afterPath="$PROJECT_DIR$/fichiers/images/menu/menu/menu1/menuAN/menuModeAN.bmp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/fichiers/images/menu1/menuAN/menuReglesAN.bmp" beforeDir="false" afterPath="$PROJECT_DIR$/fichiers/images/menu/menu/menu1/menuAN/menuReglesAN.bmp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/fichiers/images/menu1/menuChoixLangues.bmp" beforeDir="false" afterPath="$PROJECT_DIR$/fichiers/images/menu/menu/menu1/menuChoixLangues.bmp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/fichiers/images/menu1/menuFR/menu2FR.bmp" beforeDir="false" afterPath="$PROJECT_DIR$/fichiers/images/menu/menu/menu1/menuFR/menu2FR.bmp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/fichiers/images/menu1/menuFR/menuModeFR.bmp" beforeDir="false" afterPath="$PROJECT_DIR$/fichiers/images/menu/menu/menu1/menuFR/menuModeFR.bmp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/fichiers/images/menu1/menuFR/menuReglesFR.bmp" beforeDir="false" afterPath="$PROJECT_DIR$/fichiers/images/menu/menu/menu1/menuFR/menuReglesFR.bmp" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/mabiblio.c" beforeDir="false" afterPath="$PROJECT_DIR$/mabiblio.c" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/mabiblio.h" beforeDir="false" afterPath="$PROJECT_DIR$/mabiblio.h" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/mesfonctions.c" beforeDir="false" afterPath="$PROJECT_DIR$/mesfonctions.c" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -102,17 +74,22 @@
     &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,
     &quot;cf.first.check.clang-format&quot;: &quot;false&quot;,
     &quot;cidr.known.project.marker&quot;: &quot;true&quot;,
-    &quot;last_opened_file_path&quot;: &quot;C:/Users/antoi/Downloads/ECECITY&quot;,
+    &quot;last_opened_file_path&quot;: &quot;C:/Users/denis/OneDrive/Documents/ECE ing 2/Codes info/ECECITY/fichiers/images/menu/menu&quot;,
     &quot;settings.editor.selected.configurable&quot;: &quot;preferences.pluginManager&quot;,
     &quot;structure.view.defaults.are.configured&quot;: &quot;true&quot;
   }
 }</component>
+  <component name="RecentsManager">
+    <key name="CopyFile.RECENT_KEYS">
+      <recent name="C:\Users\denis\OneDrive\Documents\ECE ing 2\Codes info\ECECITY\fichiers\images\menu\menu" />
+      <recent name="C:\Users\denis\OneDrive\Documents\ECE ing 2\Codes info\ECECITY\cmake-build-debug\fichiers\images" />
+    </key>
+    <key name="MoveFile.RECENT_KEYS">
+      <recent name="C:\Users\denis\OneDrive\Documents\ECE ing 2\Codes info\ECECITY\fichiers\images\menu" />
+      <recent name="C:\Users\denis\OneDrive\Documents\ECE ing 2\Codes info\ECECITY\cmake-build-debug\fichiers\images\menu" />
+    </key>
+  </component>
   <component name="RunManager">
-    <configuration default="true" type="CLionExternalRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" USE_EXTERNAL_CONSOLE="false" PASS_PARENT_ENVS_2="true">
-      <method v="2">
-        <option name="CLION.EXTERNAL.BUILD" enabled="true" />
-      </method>
-    </configuration>
     <configuration name="ECECITY" type="CMakeRunConfiguration" factoryName="Application" REDIRECT_INPUT="false" ELEVATE="false" USE_EXTERNAL_CONSOLE="false" PASS_PARENT_ENVS_2="true" PROJECT_NAME="ECECITY" TARGET_NAME="ECECITY" CONFIG_NAME="Debug" RUN_TARGET_PROJECT_NAME="ECECITY" RUN_TARGET_NAME="ECECITY">
       <method v="2">
         <option name="com.jetbrains.cidr.execution.CidrBuildBeforeRunTaskProvider$BuildBeforeRunTask" enabled="true" />
@@ -150,7 +127,12 @@
       <workItem from="1669478161078" duration="135000" />
       <workItem from="1669478320218" duration="13825000" />
       <workItem from="1669494965278" duration="82000" />
-      <workItem from="1669495059756" duration="614000" />
+      <workItem from="1669495059756" duration="2573000" />
+      <workItem from="1669498647022" duration="186000" />
+      <workItem from="1669499166390" duration="129000" />
+      <workItem from="1669500309927" duration="53000" />
+      <workItem from="1669500493873" duration="1377000" />
+      <workItem from="1669538591485" duration="1000" />
     </task>
     <task id="LOCAL-00001" summary="amelioration du travail d'antoine">
       <created>1668615690545</created>
@@ -180,7 +162,14 @@
       <option name="project" value="LOCAL" />
       <updated>1669372254939</updated>
     </task>
-    <option name="localTasksCounter" value="5" />
+    <task id="LOCAL-00005" summary="geographie">
+      <created>1669495771915</created>
+      <option name="number" value="00005" />
+      <option name="presentableId" value="LOCAL-00005" />
+      <option name="project" value="LOCAL" />
+      <updated>1669495771915</updated>
+    </task>
+    <option name="localTasksCounter" value="6" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -214,6 +203,7 @@
     <MESSAGE value="accesibilité menu" />
     <MESSAGE value="compacteV2" />
     <MESSAGE value="ajout graphique" />
-    <option name="LAST_COMMIT_MESSAGE" value="ajout graphique" />
+    <MESSAGE value="geographie" />
+    <option name="LAST_COMMIT_MESSAGE" value="geographie" />
   </component>
 </project>
\ No newline at end of file
